<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é–“å–ã‚ŠPlanner Pro Custom</title>
    <style>
        :root { --primary: #2c3e50; --accent: #e74c3c; --ui-bg: rgba(255,255,255,0.9); }
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #ddd; touch-action: none; }
        canvas { display: block; background: #fff; }

        .ui-panel { position: fixed; background: var(--ui-bg); backdrop-filter: blur(5px); z-index: 100; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #top-bar { top: 10px; left: 10px; right: 10px; display: flex; flex-direction: column; padding: 5px 10px; gap: 5px; }
        .top-row { display: flex; align-items: center; justify-content: space-between; }
        
        #toolbar { bottom: 0; left: 0; width: 100%; display: flex; flex-direction: column; padding-bottom: max(10px, env(safe-area-inset-bottom)); }
        .scroll-menu { display: flex; overflow-x: auto; padding: 10px; gap: 8px; align-items: center; }
        
        button.tool-btn { 
            flex: 0 0 auto; padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; background: white; font-size: 11px; display: flex; flex-direction: column; align-items: center; min-width: 60px;
        }
        button.tool-btn.active { background: #e3f2fd; border-color: var(--primary); font-weight: bold; }

        #edit-menu { display: none; position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%); padding: 10px; gap: 8px; background: var(--primary); color: white; flex-wrap: wrap; justify-content: center; width: max-content; max-width: 90%; }
        #edit-menu button { background: none; border: 1px solid white; color: white; padding: 5px 10px; border-radius: 4px; font-size: 12px; }
        
        .floor-btn { padding: 5px 15px; border: 1px solid #ccc; background: #fff; border-radius: 20px; font-size: 12px; }
        .floor-btn.active { background: var(--primary); color: white; }
        #zoom-info { position: fixed; top: 80px; right: 20px; font-size: 10px; color: #666; background: rgba(255,255,255,0.7); padding: 2px 5px; border-radius: 4px; }
        
        .top-btn-group button { font-size: 11px; padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; background: #fff; }
        .sub-menu { display: flex; gap: 5px; margin-left: 5px; border-left: 1px solid #ccc; padding-left: 5px; }
        
        #cost-display { font-size: 12px; font-weight: bold; color: var(--accent); background: #fff; padding: 2px 8px; border-radius: 10px; border: 1px solid var(--accent); }
    </style>
</head>
<body>

<div id="top-bar" class="ui-panel">
    <div class="top-row">
        <div>
            <button class="floor-btn active" id="f1-btn" onclick="changeFloor(1)">1F</button>
            <button class="floor-btn" id="f2-btn" onclick="changeFloor(2)">2F</button>
        </div>
        <div id="status" style="font-size:11px; flex-grow:1; text-align:center;">ãƒ¢ãƒ¼ãƒ‰: å£ã‚’æã</div>
        <div class="top-btn-group">
            <button onclick="saveData()">ä¿å­˜</button>
            <button onclick="loadData()">èª­è¾¼</button>
            <button onclick="resetView()">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
    </div>
    <div class="top-row" style="justify-content: center; margin-top: 2px;">
        <div id="cost-display">æ¦‚ç®—ã‚³ã‚¹ãƒˆ: 0ä¸‡å††</div>
    </div>
</div>

<div id="zoom-info">ã‚ºãƒ¼ãƒ : 100%</div>

<div id="edit-menu" class="ui-panel">
    <span id="select-label" style="font-size:10px; margin-right:5px; width:100%; text-align:center;"></span>
    <button id="btn-w-up" onclick="changeSize(2, 0)">å¹…+</button>
    <button id="btn-w-down" onclick="changeSize(-2, 0)">å¹…-</button>
    <button id="btn-h-up" onclick="changeSize(0, 2)">é•·+</button>
    <button id="btn-h-down" onclick="changeSize(0, -2)">é•·-</button>
    <button onclick="rotateObject()">âŸ³ å›è»¢</button>
    <button onclick="deleteObject()" style="color:#ffadad;">ğŸ—‘ å‰Šé™¤</button>
    <button onclick="deselect()">Ã— é–‰ã˜ã‚‹</button>
</div>

<canvas id="canvas"></canvas>

<div id="toolbar" class="ui-panel">
    <div class="scroll-menu">
        <button id="btn-select" class="tool-btn" onclick="setMode('select')">ğŸ‘†<span>é¸æŠ/ç§»å‹•</span></button>
        
        <button id="btn-wall" class="tool-btn active" onclick="setMode('wall')">ğŸ§±<span>å£</span></button>
        <div class="sub-menu" id="wall-options" style="display:flex;">
            <button id="btn-wall-outer" class="tool-btn active" onclick="setWallThickness('outer')" style="min-width:40px;">å¤–</button>
            <button id="btn-wall-inner" class="tool-btn" onclick="setWallThickness('inner')" style="min-width:40px;">å†…</button>
        </div>

        <button id="btn-area-room" class="tool-btn" onclick="setMode('area', 'room')">ğŸŸ©<span>éƒ¨å±‹ã‚¨ãƒªã‚¢</span></button>
        <button id="btn-area-kitchen" class="tool-btn" onclick="setMode('area', 'kitchen')">ğŸ³<span>ã‚­ãƒƒãƒãƒ³</span></button>
        <button class="tool-btn" onclick="setAddItem('door')">ğŸšª<span>ãƒ‰ã‚¢</span></button>
        <button class="tool-btn" onclick="setAddItem('stair')">ğŸªœ<span>éšæ®µ</span></button>
        <button class="tool-btn" onclick="setAddItem('bath100')">ğŸ›<span>é¢¨å‘‚1åª</span></button>
        <button class="tool-btn" onclick="setAddItem('toilet')">ğŸš½<span>ãƒˆã‚¤ãƒ¬</span></button>
        <button class="tool-btn" onclick="setAddItem('bed')">ğŸ›<span>ãƒ™ãƒƒãƒ‰</span></button>
        <button class="tool-btn" onclick="setAddItem('dining')">ğŸª‘<span>ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°</span></button>
    </div>
</div>

<script>
    const GRID_UNIT = 20; // 1ã‚°ãƒªãƒƒãƒ‰ = 0.25é–“ (ç´„455mm)
    const REAL_M_PER_GRID = 0.455; // 1ã‚°ãƒªãƒƒãƒ‰ã‚ãŸã‚Šã®ãƒ¡ãƒ¼ãƒˆãƒ«
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let data = { 1: { objects: [] }, 2: { objects: [] } };
    let currentFloor = 1;
    let mode = 'wall'; 
    let activeAreaType = null;
    let activeItemType = null;
    let currentWallThickness = 'outer'; // 'outer' or 'inner'
    let selectedObj = null;
    let selectedWalls = [];
    let draggingObj = null;

    let camera = { x: 0, y: 0, zoom: 1.0 };
    let isDragging = false, isPinching = false;
    let lastTouch = { x: 0, y: 0 }, startDist = 0;
    
    let tempPoints = [];
    let startPos = {x:0, y:0}, currentPos = {x:0, y:0};

    function init() {
        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('touchstart', onTouchStart, {passive: false});
        canvas.addEventListener('touchmove', onTouchMove, {passive: false});
        canvas.addEventListener('touchend', onTouchEnd);
        draw();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        draw();
    }

    function screenToWorld(x, y) {
        return { x: (x - camera.x) / camera.zoom, y: (y - camera.y) / camera.zoom };
    }

    function snap(val) { return Math.round(val / GRID_UNIT) * GRID_UNIT; }

    function onTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 2) {
            isPinching = true;
            startDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
        } else {
            isDragging = true;
            const touch = e.touches[0];
            lastTouch = { x: touch.pageX, y: touch.pageY };
            
            const worldPos = screenToWorld(touch.pageX, touch.pageY);
            startPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
            currentPos = { ...startPos };

            if (mode === 'select') {
                handleSelection(startPos.x, startPos.y);
                if (selectedObj) {
                    draggingObj = selectedObj;
                    if (draggingObj.type === 'wall') {
                        selectedWalls.forEach(w => { w._origX1 = w.x1; w._origY1 = w.y1; w._origX2 = w.x2; w._origY2 = w.y2; });
                    } else if (draggingObj.type === 'area') {
                        draggingObj._origPoints = draggingObj.points.map(p => ({...p}));
                    } else {
                        draggingObj._origX = draggingObj.x; draggingObj._origY = draggingObj.y;
                    }
                }
            } else if (mode === 'area') {
                tempPoints.push({ x: startPos.x, y: startPos.y });
                if (tempPoints.length > 2 && startPos.x === tempPoints[0].x && startPos.y === tempPoints[0].y) {
                    completeArea();
                }
            } else if (mode === 'add') {
                placeItem(startPos.x, startPos.y);
            }
        }
        draw();
    }

    function onTouchMove(e) {
        e.preventDefault();
        if (isPinching && e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            const delta = dist / startDist;
            camera.zoom = Math.min(Math.max(camera.zoom * delta, 0.5), 3.0);
            startDist = dist;
            document.getElementById('zoom-info').innerText = `ã‚ºãƒ¼ãƒ : ${Math.round(camera.zoom*100)}%`;
        } else if (isDragging) {
            const touch = e.touches[0];
            if (mode === 'select') {
                if (draggingObj) {
                    const worldPos = screenToWorld(touch.pageX, touch.pageY);
                    currentPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
                    const dx = currentPos.x - startPos.x;
                    const dy = currentPos.y - startPos.y;

                    if (draggingObj.type === 'wall') {
                        selectedWalls.forEach(w => {
                            w.x1 = w._origX1 + dx; w.y1 = w._origY1 + dy; w.x2 = w._origX2 + dx; w.y2 = w._origY2 + dy;
                        });
                    } else if (draggingObj.type === 'area') {
                        draggingObj.points = draggingObj._origPoints.map(p => ({x: p.x + dx, y: p.y + dy}));
                    } else {
                        draggingObj.x = draggingObj._origX + dx; draggingObj.y = draggingObj._origY + dy;
                    }
                } else {
                    camera.x += (touch.pageX - lastTouch.x); camera.y += (touch.pageY - lastTouch.y);
                }
            } else {
                const worldPos = screenToWorld(touch.pageX, touch.pageY);
                currentPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
            }
            lastTouch = { x: touch.pageX, y: touch.pageY };
        }
        draw();
    }

    function onTouchEnd() {
        if (mode === 'wall' && isDragging) {
            if (startPos.x !== currentPos.x || startPos.y !== currentPos.y) {
                data[currentFloor].objects.push({
                    id: Date.now(), type: 'wall', thicknessType: currentWallThickness,
                    x1: startPos.x, y1: startPos.y, x2: currentPos.x, y2: currentPos.y
                });
            }
        }
        isDragging = false;
        isPinching = false;
        draggingObj = null;
        updateCost();
        draw();
    }

    function getConnectedWalls(startWall) {
        let connected = [startWall];
        let toCheck = [startWall];
        let checkedIds = new Set([startWall.id]);

        while(toCheck.length > 0) {
            let w = toCheck.pop();
            data[currentFloor].objects.forEach(o => {
                if (o.type === 'wall' && !checkedIds.has(o.id)) {
                    if (o.x1 === w.x1 && o.y1 === w.y1 || o.x1 === w.x2 && o.y1 === w.y2 ||
                        o.x2 === w.x1 && o.y2 === w.y1 || o.x2 === w.x2 && o.y2 === w.y2) {
                        connected.push(o); toCheck.push(o); checkedIds.add(o.id);
                    }
                }
            });
        }
        return connected;
    }

    function handleSelection(x, y) {
        const objs = data[currentFloor].objects;
        let found = null;
        for (let i = objs.length - 1; i >= 0; i--) {
            const o = objs[i];
            if (o.type === 'wall') {
                if (distToSegment({x, y}, {x:o.x1, y:o.y1}, {x:o.x2, y:o.y2}) < 15) found = o;
            } else if (o.type === 'area') {
                if (isPointInPoly({x,y}, o.points)) found = o;
            } else {
                let cw = (o.w || 4) * GRID_UNIT; let ch = (o.h || 4) * GRID_UNIT;
                if (x >= o.x - cw/2 && x <= o.x + cw && y >= o.y - ch/2 && y <= o.y + ch) found = o;
            }
            if (found) break;
        }

        selectedObj = found;
        if (found) {
            if (found.type === 'wall') {
                selectedWalls = getConnectedWalls(found);
                document.getElementById('select-label').innerText = `é€£ç¶šå£ (${selectedWalls.length})`;
            } else {
                selectedWalls = [];
                document.getElementById('select-label').innerText = found.label || found.type;
            }

            const isSizeable = (found.type !== 'wall' && found.type !== 'area');
            document.getElementById('btn-w-up').style.display = isSizeable ? 'inline-block' : 'none';
            document.getElementById('btn-w-down').style.display = isSizeable ? 'inline-block' : 'none';
            document.getElementById('btn-h-up').style.display = isSizeable ? 'inline-block' : 'none';
            document.getElementById('btn-h-down').style.display = isSizeable ? 'inline-block' : 'none';

            document.getElementById('edit-menu').style.display = 'flex';
        } else {
            deselect();
        }
    }

    function completeArea() {
        if (tempPoints.length < 3) return;
        data[currentFloor].objects.push({
            id: Date.now(), type: 'area', areaType: activeAreaType,
            points: [...tempPoints],
            color: activeAreaType === 'kitchen' ? 'rgba(243, 156, 18, 0.4)' : 'rgba(52, 152, 219, 0.3)',
        });
        tempPoints = [];
        updateCost();
        setMode('select');
    }

    function setMode(m, sub) {
        mode = m; activeAreaType = sub;
        tempPoints = [];
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        
        if (sub) document.getElementById('btn-area-'+sub)?.classList.add('active');
        else if (document.getElementById('btn-'+m)) document.getElementById('btn-'+m).classList.add('active');
        
        document.getElementById('wall-options').style.display = m === 'wall' ? 'flex' : 'none';
        document.getElementById('status').innerText = `ãƒ¢ãƒ¼ãƒ‰: ${m} ${sub||''}`;
        deselect();
    }

    function setWallThickness(type) {
        currentWallThickness = type;
        document.getElementById('btn-wall-outer').classList.toggle('active', type==='outer');
        document.getElementById('btn-wall-inner').classList.toggle('active', type==='inner');
    }

    function setAddItem(type) {
        mode = 'add'; activeItemType = type;
        setMode('add');
        document.getElementById('status').innerText = `é…ç½®ãƒ¢ãƒ¼ãƒ‰: ${type}`;
    }

    function placeItem(x, y) {
        const presets = {
            'door': { w: 4, h: 4, type: 'door' },
            'stair': { w: 4, h: 8, type: 'rect', label: 'éšæ®µ', color: '#bdc3c7' },
            'bath100': { w: 8, h: 8, type: 'rect', label: 'é¢¨å‘‚', color: '#3498db' },
            'toilet': { w: 4, h: 6, type: 'rect', label: 'ãƒˆã‚¤ãƒ¬', color: '#1abc9c' },
            'bed': { w: 4.5, h: 9, type: 'rect', label: 'ãƒ™ãƒƒãƒ‰', color: '#9b59b6' },
            'dining': { w: 6, h: 6, type: 'rect', label: 'ï¾€ï¾ï½²ï¾†ï¾ï½¸ï¾', color: '#e67e22' }
        };
        const p = presets[activeItemType];
        data[currentFloor].objects.push({ ...p, id: Date.now(), x, y, rotation: 0 });
        setMode('select');
    }

    // --- è¨ˆç®—æ©Ÿèƒ½ ---
    function calcPolygonAreaM2(points) {
        let areaPx = 0;
        for(let i=0, j=points.length-1; i<points.length; j=i++) {
            areaPx += (points[j].x + points[i].x) * (points[j].y - points[i].y);
        }
        let areaGridSq = Math.abs(areaPx / 2) / (GRID_UNIT * GRID_UNIT);
        return areaGridSq * (REAL_M_PER_GRID * REAL_M_PER_GRID);
    }

    function updateCost() {
        let totalCost = 0; // ä¸‡å˜ä½
        // å…¨ãƒ•ãƒ­ã‚¢ã‚’è¨ˆç®—å¯¾è±¡ã¨ã™ã‚‹å ´åˆ
        [1, 2].forEach(floor => {
            data[floor].objects.forEach(o => {
                if (o.type === 'wall') {
                    let lenM = (Math.hypot(o.x2 - o.x1, o.y2 - o.y1) / GRID_UNIT) * REAL_M_PER_GRID;
                    totalCost += lenM * 1.5; // å£1m = 1.5ä¸‡å††ã®æ¦‚ç®—
                } else if (o.type === 'area') {
                    let m2 = calcPolygonAreaM2(o.points);
                    totalCost += m2 * 20; // æ–½å·¥é¢ç©1å¹³ç±³ = 20ä¸‡å††ã®æ¦‚ç®—
                }
            });
        });
        document.getElementById('cost-display').innerText = `æ¦‚ç®—ã‚³ã‚¹ãƒˆ: ç´„ ${Math.round(totalCost).toLocaleString()} ä¸‡å††`;
    }

    // --- æç”»å‡¦ç† ---
    function draw() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.translate(camera.x, camera.y);
        ctx.scale(camera.zoom, camera.zoom);

        // ã‚°ãƒªãƒƒãƒ‰
        ctx.strokeStyle = '#eee';
        for(let i=-2000; i<3000; i+=GRID_UNIT){
            ctx.beginPath(); ctx.lineWidth=i%(GRID_UNIT*4)===0?1:0.3;
            ctx.moveTo(i,-2000); ctx.lineTo(i,3000); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-2000,i); ctx.lineTo(3000,i); ctx.stroke();
        }

        // ä¸‹éšã®è¡¨ç¤ºï¼ˆ2Fç·¨é›†æ™‚ï¼‰
        if (currentFloor === 2) {
            ctx.globalAlpha = 0.2;
            data[1].objects.forEach(renderObj);
            ctx.globalAlpha = 1.0;
        }

        data[currentFloor].objects.forEach(renderObj);

        // ä½œæ¥­ä¸­è¡¨ç¤º
        if (mode === 'wall' && isDragging) {
            ctx.strokeStyle = '#3498db'; 
            ctx.lineWidth = currentWallThickness === 'outer' ? 8 : 4;
            ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(currentPos.x, currentPos.y); ctx.stroke();
        }
        if (tempPoints.length > 0) {
            ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 2;
            ctx.beginPath();
            tempPoints.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.lineTo(currentPos.x, currentPos.y);
            ctx.stroke();
            ctx.fillStyle = 'red';
            ctx.beginPath(); ctx.arc(tempPoints[0].x, tempPoints[0].y, 8/camera.zoom, 0, Math.PI*2); ctx.fill();
        }
    }

    function renderObj(o) {
        ctx.save();
        const isSelected = selectedObj && (selectedObj.id === o.id || (o.type === 'wall' && selectedWalls.some(w => w.id === o.id)));
        
        if (o.type === 'wall') {
            ctx.strokeStyle = isSelected ? 'red' : '#333';
            ctx.lineWidth = o.thicknessType === 'inner' ? 4 : 8; // å¤–å£/å†…å£ã§å¤ªã•ã‚’å¤‰ãˆã‚‹
            ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(o.x1, o.y1); ctx.lineTo(o.x2, o.y2); ctx.stroke();
            
        } else if (o.type === 'area') {
            ctx.fillStyle = o.color;
            ctx.beginPath();
            o.points.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.closePath(); ctx.fill();
            ctx.strokeStyle = isSelected ? 'red' : '#7f8c8d';
            ctx.lineWidth = 2; ctx.stroke();

            // é¢ç©ãƒ»ç•³æ•°ã®è¡¨ç¤º
            let cx = 0, cy = 0;
            o.points.forEach(p => { cx += p.x; cy += p.y; });
            cx /= o.points.length; cy /= o.points.length;
            
            let m2 = calcPolygonAreaM2(o.points);
            let jou = m2 / 1.62; // 1å¸– = ç´„1.62å¹³ç±³
            
            ctx.fillStyle = '#333'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
            ctx.fillText(`${m2.toFixed(1)}ã¡ (${jou.toFixed(1)}å¸–)`, cx, cy);

        } else if (o.type === 'door') {
            ctx.translate(o.x, o.y); ctx.rotate(o.rotation * Math.PI / 180);
            ctx.strokeStyle = isSelected ? 'red' : '#e74c3c'; ctx.lineWidth = 3;
            const size = o.w * GRID_UNIT;
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, size); ctx.stroke();
            ctx.setLineDash([5, 5]);
            ctx.beginPath(); ctx.arc(0, 0, size, Math.PI/2, 0, true); ctx.stroke();
        } else {
            ctx.translate(o.x, o.y); ctx.rotate(o.rotation * Math.PI / 180);
            ctx.fillStyle = o.color; ctx.strokeStyle = isSelected ? 'red' : '#333';
            ctx.fillRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            ctx.strokeRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            ctx.fillStyle = '#000'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
            ctx.fillText(o.label, (o.w * GRID_UNIT)/2, (o.h * GRID_UNIT)/2);
        }
        ctx.restore();
    }

    // --- æ•°å­¦ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---
    function distToSegment(p, v, w) {
        const l2 = Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
        if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
    }
    
    function isPointInPoly(p, poly) {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            if (((poly[i].y > p.y) !== (poly[j].y > p.y)) && (p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) inside = !inside;
        }
        return inside;
    }

    // --- UIã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç† ---
    function rotateObject() { if(selectedObj && selectedObj.type !== 'wall') { selectedObj.rotation = (selectedObj.rotation + 90) % 360; draw(); } }
    function changeSize(dw, dh) { if (selectedObj && selectedObj.w !== undefined) { selectedObj.w = Math.max(2, selectedObj.w + dw); selectedObj.h = Math.max(2, selectedObj.h + dh); draw(); } }
    
    function deleteObject() { 
        if(selectedObj) { 
            if (selectedObj.type === 'wall' && selectedWalls.length > 0) {
                const idsToRemove = selectedWalls.map(w => w.id);
                data[currentFloor].objects = data[currentFloor].objects.filter(o => !idsToRemove.includes(o.id));
            } else {
                data[currentFloor].objects = data[currentFloor].objects.filter(o => o.id !== selectedObj.id); 
            }
            updateCost(); deselect(); 
        } 
    }
    
    function deselect() { selectedObj = null; selectedWalls = []; document.getElementById('edit-menu').style.display = 'none'; draw(); }
    function changeFloor(f) { currentFloor = f; document.getElementById('f1-btn').classList.toggle('active', f===1); document.getElementById('f2-btn').classList.toggle('active', f===2); deselect(); }
    function resetView() { camera = { x: 0, y: 0, zoom: 1.0 }; draw(); }

    function saveData() { localStorage.setItem('madori_planner_data', JSON.stringify(data)); alert('ä¿å­˜ã—ã¾ã—ãŸ'); }
    function loadData() { 
        const saved = localStorage.getItem('madori_planner_data'); 
        if (saved) { data = JSON.parse(saved); updateCost(); deselect(); alert('èª­è¾¼ã—ã¾ã—ãŸ'); } 
    }

    init();
</script>
</body>
</html>
