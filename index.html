<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é–“å–ã‚ŠPlanner Pro Enhanced</title>
    <style>
        :root { 
            --primary: #2c3e50; 
            --accent: #e74c3c; 
            --ui-bg: rgba(255,255,255,0.95); 
            --locked: #f39c12;
            --warning: #e67e22;
        }
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Segoe UI', -apple-system, sans-serif; 
            background: #ddd; 
            touch-action: none; 
        }
        canvas { display: block; background: #fff; cursor: crosshair; }

        .ui-panel { 
            position: fixed; 
            background: var(--ui-bg); 
            backdrop-filter: blur(8px); 
            z-index: 100; 
            border-radius: 8px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.15); 
        }
        
        #top-bar { 
            top: 10px; 
            left: 10px; 
            right: 10px; 
            display: flex; 
            flex-direction: column; 
            padding: 8px 12px; 
            gap: 8px; 
        }
        
        .top-row { 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            gap: 10px;
            flex-wrap: wrap;
        }
        
        #left-panel {
            top: 120px;
            left: 10px;
            width: 200px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: transform 0.3s ease;
        }
        
        #left-panel.hidden {
            transform: translateX(-220px);
        }
        
        #panel-toggle {
            position: fixed;
            top: 120px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: var(--ui-bg);
            border-radius: 8px;
            border: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            z-index: 101;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: left 0.3s ease;
        }
        
        #panel-toggle.panel-open {
            left: 220px;
        }
        
        #toolbar { 
            bottom: 0; 
            left: 0; 
            width: 100%; 
            display: flex; 
            flex-direction: column; 
            padding-bottom: max(10px, env(safe-area-inset-bottom)); 
        }
        
        .scroll-menu { 
            display: flex; 
            overflow-x: auto; 
            padding: 10px; 
            gap: 8px; 
            align-items: center; 
        }
        
        button.tool-btn { 
            flex: 0 0 auto; 
            padding: 8px 12px; 
            border-radius: 6px; 
            border: 1px solid #ddd; 
            background: white; 
            font-size: 11px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            min-width: 60px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button.tool-btn:hover { 
            background: #f8f9fa; 
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        button.tool-btn.active { 
            background: #e3f2fd; 
            border-color: var(--primary); 
            font-weight: bold; 
        }

        #edit-menu { 
            display: none; 
            position: absolute; 
            bottom: 130px; 
            left: 50%; 
            transform: translateX(-50%); 
            padding: 12px; 
            gap: 8px; 
            background: var(--primary); 
            color: white; 
            flex-wrap: wrap; 
            justify-content: center; 
            width: max-content; 
            max-width: 90%; 
        }
        
        #edit-menu button { 
            background: none; 
            border: 1px solid white; 
            color: white; 
            padding: 6px 12px; 
            border-radius: 4px; 
            font-size: 12px; 
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #edit-menu button:hover {
            background: rgba(255,255,255,0.2);
        }
        
        #edit-menu button.locked-btn {
            background: var(--locked);
            border-color: var(--locked);
        }
        
        .floor-btn { 
            padding: 6px 16px; 
            border: 1px solid #ccc; 
            background: #fff; 
            border-radius: 20px; 
            font-size: 12px; 
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .floor-btn:hover {
            background: #f8f9fa;
        }
        
        .floor-btn.active { 
            background: var(--primary); 
            color: white; 
        }
        
        #zoom-info { 
            position: fixed; 
            top: 80px; 
            right: 20px; 
            font-size: 10px; 
            color: #666; 
            background: rgba(255,255,255,0.9); 
            padding: 4px 8px; 
            border-radius: 4px; 
        }
        
        .top-btn-group button { 
            font-size: 11px; 
            padding: 5px 10px; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
            background: #fff; 
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .top-btn-group button:hover:not(:disabled) {
            background: #f8f9fa;
            border-color: var(--primary);
        }
        
        .top-btn-group button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .sub-menu { 
            display: flex; 
            gap: 5px; 
            margin-left: 5px; 
            border-left: 1px solid #ccc; 
            padding-left: 5px; 
        }
        
        #cost-display { 
            font-size: 12px; 
            font-weight: bold; 
            color: var(--accent); 
            background: #fff; 
            padding: 4px 10px; 
            border-radius: 10px; 
            border: 1px solid var(--accent); 
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            border-radius: 4px;
            background: white;
            border: 1px solid #ddd;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .layer-item:hover {
            background: #f8f9fa;
        }
        
        .layer-item.active {
            background: #e3f2fd;
            border-color: var(--primary);
        }
        
        .layer-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .layer-name {
            flex: 1;
            font-size: 11px;
        }
        
        .layer-opacity {
            width: 60px;
            height: 4px;
        }
        
        .panel-section {
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            margin-bottom: 8px;
        }
        
        .panel-section:last-child {
            border-bottom: none;
        }
        
        .panel-title {
            font-size: 10px;
            font-weight: bold;
            color: #666;
            margin-bottom: 6px;
            text-transform: uppercase;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            padding: 4px;
            cursor: pointer;
        }
        
        .checkbox-item:hover {
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        .color-picker-btn {
            width: 30px;
            height: 20px;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
        }
        
        #warning-panel {
            position: fixed;
            top: 100px;
            right: 20px;
            max-width: 300px;
            padding: 10px;
            background: #fff3cd;
            border: 2px solid var(--warning);
            border-radius: 6px;
            display: none;
            z-index: 200;
        }
        
        .warning-title {
            font-weight: bold;
            color: var(--warning);
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .warning-item {
            font-size: 11px;
            color: #856404;
            margin: 3px 0;
        }
        
        @media (max-width: 768px) {
            .top-row {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>

<div id="top-bar" class="ui-panel">
    <div class="top-row">
        <div>
            <button class="floor-btn active" id="f1-btn" onclick="changeFloor(1)">1F</button>
            <button class="floor-btn" id="f2-btn" onclick="changeFloor(2)">2F</button>
        </div>
        <div id="status" style="font-size:11px; flex-grow:1; text-align:center;">ãƒ¢ãƒ¼ãƒ‰: å£ã‚’æã</div>
        <div class="top-btn-group">
            <button onclick="undo()" id="undo-btn" title="å…ƒã«æˆ»ã™ (Ctrl+Z)">â†¶ æˆ»ã™</button>
            <button onclick="redo()" id="redo-btn" title="ã‚„ã‚Šç›´ã— (Ctrl+Y)">â†· é€²ã‚€</button>
            <button onclick="checkAlignment()">æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯</button>
            <button onclick="exportData()">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
            <button onclick="importData()">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
            <button onclick="saveData()">ä¿å­˜</button>
            <button onclick="loadData()">èª­è¾¼</button>
            <button onclick="resetView()">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
    </div>
    <div class="top-row" style="justify-content: center; margin-top: 2px;">
        <div id="cost-display">æ¦‚ç®—ã‚³ã‚¹ãƒˆ: 0ä¸‡å††</div>
    </div>
</div>

<button id="panel-toggle" onclick="togglePanel()">â˜°</button>

<div id="left-panel" class="ui-panel hidden">
    <div class="panel-section">
        <div class="panel-title">ãƒ¬ã‚¤ãƒ¤ãƒ¼</div>
        <div id="layer-list"></div>
        <button onclick="addLayer()" style="width:100%; padding:4px; font-size:10px; margin-top:5px; cursor: pointer;">+ ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½åŠ </button>
    </div>
    
    <div class="panel-section">
        <div class="panel-title">è¡¨ç¤ºè¨­å®š</div>
        <div class="checkbox-item">
            <input type="checkbox" id="show-lighting" onchange="toggleLighting()">
            <label for="show-lighting">æ¡å…‰ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</label>
        </div>
        <div class="checkbox-item">
            <input type="checkbox" id="show-dimensions" checked onchange="draw()">
            <label for="show-dimensions">å¤–å‘¨å¯¸æ³•è¡¨ç¤º</label>
        </div>
        <div class="checkbox-item">
            <input type="checkbox" id="show-grid" checked onchange="draw()">
            <label for="show-grid">ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º</label>
        </div>
    </div>
    
    <div class="panel-section">
        <div class="panel-title">å£ã®è‰²è¨­å®š</div>
        <select id="wall-color-preset" onchange="updateWallColorPreview()" style="width:100%; font-size:10px; padding:3px;">
            <option value="#333333">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆé»’ï¼‰</option>
            <option value="#3498db">å¯å®¤ï¼ˆé’ï¼‰</option>
            <option value="#2ecc71">ãƒªãƒ“ãƒ³ã‚°ï¼ˆç·‘ï¼‰</option>
            <option value="#f39c12">æ¤œè¨ä¸­ï¼ˆã‚ªãƒ¬ãƒ³ã‚¸ï¼‰</option>
            <option value="#e74c3c">ä»®ç½®ãï¼ˆèµ¤ï¼‰</option>
            <option value="#9b59b6">å­ä¾›éƒ¨å±‹ï¼ˆç´«ï¼‰</option>
            <option value="custom">ã‚«ã‚¹ã‚¿ãƒ </option>
        </select>
        <input type="color" id="wall-color-custom" style="width:100%; margin-top:5px; display:none;" onchange="updateWallColorPreview()">
        <div id="wall-color-preview" class="color-picker-btn" style="width:100%; height:25px; margin-top:5px; background:#333;"></div>
    </div>
</div>

<div id="zoom-info">ã‚ºãƒ¼ãƒ : 100%</div>

<div id="warning-panel">
    <div class="warning-title">âš  æ•´åˆæ€§ã®å•é¡Œ</div>
    <div id="warning-list"></div>
</div>

<div id="edit-menu" class="ui-panel">
    <span id="select-label" style="font-size:10px; margin-right:5px; width:100%; text-align:center;"></span>
    <button id="btn-w-up" onclick="changeSize(2, 0)">å¹…+</button>
    <button id="btn-w-down" onclick="changeSize(-2, 0)">å¹…-</button>
    <button id="btn-h-up" onclick="changeSize(0, 2)">é•·+</button>
    <button id="btn-h-down" onclick="changeSize(0, -2)">é•·-</button>
    <button onclick="rotateObject()">âŸ³ å›è»¢</button>
    <button onclick="toggleLock()" id="lock-btn">ğŸ”“ ãƒ­ãƒƒã‚¯</button>
    <button onclick="changeWallColor()">ğŸ¨ è‰²å¤‰æ›´</button>
    <button onclick="deleteObject()" style="color:#ffadad;">ğŸ—‘ å‰Šé™¤</button>
    <button onclick="deselect()">Ã— é–‰ã˜ã‚‹</button>
</div>

<canvas id="canvas"></canvas>

<div id="toolbar" class="ui-panel">
    <div class="scroll-menu">
        <button id="btn-select" class="tool-btn" onclick="setMode('select')">ğŸ‘†<span>é¸æŠ/ç§»å‹•</span></button>
        <button id="btn-eraser" class="tool-btn" onclick="setMode('eraser')">ğŸ§¹<span>æ¶ˆã—ã‚´ãƒ </span></button>
        
        <button id="btn-wall" class="tool-btn active" onclick="setMode('wall')">ğŸ§±<span>å£</span></button>
        <div class="sub-menu" id="wall-options" style="display:flex;">
            <button id="btn-wall-outer" class="tool-btn active" onclick="setWallThickness('outer')" style="min-width:40px;">å¤–</button>
            <button id="btn-wall-inner" class="tool-btn" onclick="setWallThickness('inner')" style="min-width:40px;">å†…</button>
        </div>

        <button id="btn-area-room" class="tool-btn" onclick="setMode('area', 'room')">ğŸŸ©<span>éƒ¨å±‹ã‚¨ãƒªã‚¢</span></button>
        <button id="btn-area-kitchen" class="tool-btn" onclick="setMode('area', 'kitchen')">ğŸ³<span>ã‚­ãƒƒãƒãƒ³</span></button>
        <button class="tool-btn" onclick="setAddItem('door')">ğŸšª<span>ãƒ‰ã‚¢</span></button>
        <button class="tool-btn" onclick="setAddItem('window')">ğŸªŸ<span>çª“</span></button>
        <button class="tool-btn" onclick="setAddItem('stair')">ğŸªœ<span>éšæ®µ</span></button>
        <button class="tool-btn" onclick="setAddItem('pillar')">â¬›<span>æŸ±</span></button>
        <button class="tool-btn" onclick="setAddItem('bath100')">ğŸ›<span>é¢¨å‘‚1åª</span></button>
        <button class="tool-btn" onclick="setAddItem('toilet')">ğŸš½<span>ãƒˆã‚¤ãƒ¬</span></button>
        <button class="tool-btn" onclick="setAddItem('bed')">ğŸ›<span>ãƒ™ãƒƒãƒ‰</span></button>
        <button class="tool-btn" onclick="setAddItem('dining')">ğŸª‘<span>ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°</span></button>
    </div>
</div>

<script>
    const GRID_UNIT = 20; // 1ã‚°ãƒªãƒƒãƒ‰ = 0.25é–“ (ç´„455mm)
    const REAL_M_PER_GRID = 0.455; // 1ã‚°ãƒªãƒƒãƒ‰ã‚ãŸã‚Šã®ãƒ¡ãƒ¼ãƒˆãƒ«
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æ‹¡å¼µ
    let data = { 
        1: { 
            layers: [
                { id: 'layer1', name: 'ãƒ¬ã‚¤ãƒ¤ãƒ¼1', visible: true, opacity: 1.0, objects: [] }
            ],
            activeLayer: 'layer1'
        }, 
        2: { 
            layers: [
                { id: 'layer1', name: 'ãƒ¬ã‚¤ãƒ¤ãƒ¼1', visible: true, opacity: 1.0, objects: [] }
            ],
            activeLayer: 'layer1'
        } 
    };
    
    let currentFloor = 1;
    let mode = 'wall'; 
    let activeAreaType = null;
    let activeItemType = null;
    let currentWallThickness = 'outer';
    let currentWallColor = '#333333';
    let selectedObj = null;
    let selectedWalls = [];
    let draggingObj = null;
    let eraserMode = false; // æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰

    // Undo/Redoç”¨ã®å±¥æ­´ç®¡ç†
    let history = [];
    let historyIndex = -1;
    const MAX_HISTORY = 50;

    let camera = { x: 0, y: 0, zoom: 1.0 };
    let isDragging = false, isPinching = false, isPanning = false;
    let lastTouch = { x: 0, y: 0 }, lastMouse = { x: 0, y: 0 }, startDist = 0;
    
    let tempPoints = [];
    let startPos = {x:0, y:0}, currentPos = {x:0, y:0};
    let showLighting = false;
    let nextId = 1;

    // ãƒ‘ãƒãƒ«è¡¨ç¤ºçŠ¶æ…‹
    let panelOpen = false;

    function togglePanel() {
        panelOpen = !panelOpen;
        const panel = document.getElementById('left-panel');
        const toggle = document.getElementById('panel-toggle');
        
        if (panelOpen) {
            panel.classList.remove('hidden');
            toggle.classList.add('panel-open');
            toggle.textContent = 'âœ•';
        } else {
            panel.classList.add('hidden');
            toggle.classList.remove('panel-open');
            toggle.textContent = 'â˜°';
        }
    }

    // ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½
    function exportData() {
        const dataStr = JSON.stringify(data, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `madori_plan_${new Date().toISOString().slice(0,10)}.json`;
        a.click();
        URL.revokeObjectURL(url);
        alert('ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
    }

    function importData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        data = JSON.parse(event.target.result);
                        updateLayerList();
                        updateCost();
                        deselect();
                        saveHistory();
                        alert('ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
                    } catch (err) {
                        alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                };
                reader.readAsText(file);
            }
        };
        input.click();
    }

    function init() {
        resize();
        window.addEventListener('resize', resize);
        
        // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('touchstart', onTouchStart, {passive: false});
        canvas.addEventListener('touchmove', onTouchMove, {passive: false});
        canvas.addEventListener('touchend', onTouchEnd);
        
        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆPCå¯¾å¿œï¼‰
        canvas.addEventListener('mousedown', onMouseDown);
        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('mouseup', onMouseUp);
        canvas.addEventListener('wheel', onWheel, {passive: false});
        
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
        window.addEventListener('keydown', onKeyDown);
        
        updateLayerList();
        saveHistory(); // åˆæœŸçŠ¶æ…‹ã‚’ä¿å­˜
        draw();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        draw();
    }

    function screenToWorld(x, y) {
        return { x: (x - camera.x) / camera.zoom, y: (y - camera.y) / camera.zoom };
    }

    function snap(val) { return Math.round(val / GRID_UNIT) * GRID_UNIT; }

    // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ï¼ˆPCå¯¾å¿œï¼‰
    function onMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
            // ä¸­ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯Shift+å·¦ã‚¯ãƒªãƒƒã‚¯ã§ãƒ‘ãƒ³
            isPanning = true;
            lastMouse = { x, y };
            canvas.style.cursor = 'grabbing';
        } else if (e.button === 0) {
            const worldPos = screenToWorld(x, y);
            const snapPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
            startPos = { ...snapPos };
            currentPos = { ...snapPos };
            
            // é¸æŠãƒ¢ãƒ¼ãƒ‰æ™‚ã€ä½•ã‚‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãªã„å ´åˆã¯ãƒ‘ãƒ³ç§»å‹•
            if (mode === 'select') {
                // ä¸€æ™‚çš„ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¢ã™
                const activeLayer = getActiveLayer();
                let hitObject = false;
                
                // å£ã®ãƒ’ãƒƒãƒˆãƒã‚§ãƒƒã‚¯
                for (let obj of activeLayer.objects) {
                    if (obj.type === 'wall') {
                        const dist = distToSegment(snapPos, { x: obj.x1, y: obj.y1 }, { x: obj.x2, y: obj.y2 });
                        if (dist < 20 / camera.zoom) {
                            hitObject = true;
                            break;
                        }
                    }
                }
                
                // ãã®ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ’ãƒƒãƒˆãƒã‚§ãƒƒã‚¯
                if (!hitObject) {
                    for (let obj of [...activeLayer.objects].reverse()) {
                        if (obj.type === 'area' && isPointInPoly(snapPos, obj.points)) {
                            hitObject = true;
                            break;
                        } else if (obj.type !== 'wall' && obj.type !== 'area') {
                            const w = (obj.w || 0) * GRID_UNIT;
                            const h = (obj.h || 0) * GRID_UNIT;
                            const margin = 10 / camera.zoom;
                            if (snapPos.x >= obj.x - margin && snapPos.x <= obj.x + w + margin && 
                                snapPos.y >= obj.y - margin && snapPos.y <= obj.y + h + margin) {
                                hitObject = true;
                                break;
                            }
                        }
                    }
                }
                
                if (!hitObject) {
                    // ä½•ã‚‚ãªã„å ´æ‰€ã‚’ã‚¯ãƒªãƒƒã‚¯ â†’ ãƒ‘ãƒ³ç§»å‹•
                    isPanning = true;
                    lastMouse = { x, y };
                    canvas.style.cursor = 'grabbing';
                    return;
                }
            }
            
            isDragging = true;
            lastMouse = { x, y };
            handleInteractionStart(startPos);
        }
    }

    function onMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (isPanning) {
            const dx = x - lastMouse.x;
            const dy = y - lastMouse.y;
            camera.x += dx;
            camera.y += dy;
            lastMouse = { x, y };
            draw();
        } else if (isDragging) {
            const worldPos = screenToWorld(x, y);
            currentPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
            
            handleInteractionMove(currentPos);
            lastMouse = { x, y };
        }
    }

    function onMouseUp(e) {
        if (isPanning) {
            isPanning = false;
            canvas.style.cursor = 'crosshair';
        } else if (isDragging) {
            const wasDraggingObject = (draggingObj !== null);
            isDragging = false;
            handleInteractionEnd();
            
            // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç§»å‹•ã—ãŸå ´åˆã¯å±¥æ­´ã‚’ä¿å­˜
            if (wasDraggingObject && mode === 'select') {
                saveHistory();
            }
        }
    }

    function onWheel(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const worldBefore = screenToWorld(mouseX, mouseY);
        const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
        camera.zoom = Math.max(0.1, Math.min(5, camera.zoom * zoomDelta));
        
        const worldAfter = screenToWorld(mouseX, mouseY);
        camera.x += (worldAfter.x - worldBefore.x) * camera.zoom;
        camera.y += (worldAfter.y - worldBefore.y) * camera.zoom;
        
        document.getElementById('zoom-info').innerText = `ã‚ºãƒ¼ãƒ : ${Math.round(camera.zoom * 100)}%`;
        draw();
    }

    // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
    function onTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 2) {
            isPinching = true;
            startDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
        } else {
            const touch = e.touches[0];
            lastTouch = { x: touch.pageX, y: touch.pageY };
            
            const worldPos = screenToWorld(touch.pageX, touch.pageY);
            startPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
            currentPos = { ...startPos };
            
            // é¸æŠãƒ¢ãƒ¼ãƒ‰æ™‚ã€ä½•ã‚‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãªã„å ´åˆã¯ãƒ‘ãƒ³ç§»å‹•
            if (mode === 'select') {
                const activeLayer = getActiveLayer();
                let hitObject = false;
                
                // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ’ãƒƒãƒˆãƒã‚§ãƒƒã‚¯
                for (let obj of activeLayer.objects) {
                    if (obj.type === 'wall') {
                        const dist = distToSegment(startPos, { x: obj.x1, y: obj.y1 }, { x: obj.x2, y: obj.y2 });
                        if (dist < 20 / camera.zoom) {
                            hitObject = true;
                            break;
                        }
                    } else if (obj.type === 'area' && isPointInPoly(startPos, obj.points)) {
                        hitObject = true;
                        break;
                    } else if (obj.type !== 'wall' && obj.type !== 'area') {
                        const w = (obj.w || 0) * GRID_UNIT;
                        const h = (obj.h || 0) * GRID_UNIT;
                        const margin = 10 / camera.zoom;
                        if (startPos.x >= obj.x - margin && startPos.x <= obj.x + w + margin && 
                            startPos.y >= obj.y - margin && startPos.y <= obj.y + h + margin) {
                            hitObject = true;
                            break;
                        }
                    }
                }
                
                if (!hitObject) {
                    // ä½•ã‚‚ãªã„å ´æ‰€ã‚’ã‚¿ãƒƒãƒ â†’ ãƒ‘ãƒ³ç§»å‹•
                    isPanning = true;
                    canvas.style.cursor = 'grabbing';
                    return;
                }
            }

            isDragging = true;
            handleInteractionStart(startPos);
        }
    }

    function onTouchMove(e) {
        e.preventDefault();
        if (isPinching && e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            const zoomDelta = dist / startDist;
            camera.zoom = Math.max(0.1, Math.min(5, camera.zoom * zoomDelta));
            startDist = dist;
            document.getElementById('zoom-info').innerText = `ã‚ºãƒ¼ãƒ : ${Math.round(camera.zoom * 100)}%`;
            draw();
        } else if (isPanning && e.touches.length === 1) {
            // ãƒ‘ãƒ³ç§»å‹•å‡¦ç†
            const touch = e.touches[0];
            const dx = touch.pageX - lastTouch.x;
            const dy = touch.pageY - lastTouch.y;
            camera.x += dx;
            camera.y += dy;
            lastTouch = { x: touch.pageX, y: touch.pageY };
            draw();
        } else if (isDragging && e.touches.length === 1) {
            const touch = e.touches[0];
            const worldPos = screenToWorld(touch.pageX, touch.pageY);
            currentPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
            
            handleInteractionMove(currentPos);
            lastTouch = { x: touch.pageX, y: touch.pageY };
        }
    }

    function onTouchEnd(e) {
        if (e.touches.length === 0) {
            const wasDraggingObject = (draggingObj !== null);
            isPinching = false;
            isPanning = false;
            isDragging = false;
            canvas.style.cursor = 'crosshair';
            handleInteractionEnd();
            
            // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç§»å‹•ã—ãŸå ´åˆã¯å±¥æ­´ã‚’ä¿å­˜
            if (wasDraggingObject && mode === 'select') {
                saveHistory();
            }
        }
    }

    // çµ±åˆã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†
    function handleInteractionStart(pos) {
        if (mode === 'eraser') {
            // æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰ï¼šã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤
            const activeLayer = getActiveLayer();
            let deletedSomething = false;
            
            // å£ã®å‰Šé™¤ãƒã‚§ãƒƒã‚¯
            for (let i = activeLayer.objects.length - 1; i >= 0; i--) {
                const obj = activeLayer.objects[i];
                if (obj.type === 'wall') {
                    const dist = distToSegment(pos, { x: obj.x1, y: obj.y1 }, { x: obj.x2, y: obj.y2 });
                    if (dist < 20 / camera.zoom) {
                        if (obj.locked) {
                            alert('ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å‰Šé™¤ã§ãã¾ã›ã‚“');
                            return;
                        }
                        activeLayer.objects.splice(i, 1);
                        deletedSomething = true;
                        break;
                    }
                }
            }
            
            // ãã®ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‰Šé™¤ãƒã‚§ãƒƒã‚¯
            if (!deletedSomething) {
                for (let i = activeLayer.objects.length - 1; i >= 0; i--) {
                    const obj = activeLayer.objects[i];
                    if (obj.type === 'area' && isPointInPoly(pos, obj.points)) {
                        if (obj.locked) {
                            alert('ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å‰Šé™¤ã§ãã¾ã›ã‚“');
                            return;
                        }
                        activeLayer.objects.splice(i, 1);
                        deletedSomething = true;
                        break;
                    } else if (obj.type !== 'wall' && obj.type !== 'area') {
                        const w = (obj.w || 0) * GRID_UNIT;
                        const h = (obj.h || 0) * GRID_UNIT;
                        const margin = 10 / camera.zoom;
                        if (pos.x >= obj.x - margin && pos.x <= obj.x + w + margin && 
                            pos.y >= obj.y - margin && pos.y <= obj.y + h + margin) {
                            if (obj.locked) {
                                alert('ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å‰Šé™¤ã§ãã¾ã›ã‚“');
                                return;
                            }
                            activeLayer.objects.splice(i, 1);
                            deletedSomething = true;
                            break;
                        }
                    }
                }
            }
            
            if (deletedSomething) {
                updateCost();
                saveHistory();
                draw();
            }
            return;
        }
        
        if (mode === 'select') {
            handleSelection(pos.x, pos.y);
            if (selectedObj) {
                // ãƒ­ãƒƒã‚¯ãƒã‚§ãƒƒã‚¯ã¯ç§»å‹•é–‹å§‹æ™‚ã®ã¿
                if (selectedObj.locked) {
                    // ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¦ã‚‚é¸æŠã¯ã§ãã‚‹ï¼ˆç·¨é›†ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã§ãƒ­ãƒƒã‚¯è§£é™¤å¯èƒ½ï¼‰
                    return;
                }
                draggingObj = selectedObj;
                if (draggingObj.type === 'wall') {
                    selectedWalls.forEach(w => { 
                        w._origX1 = w.x1; 
                        w._origY1 = w.y1; 
                        w._origX2 = w.x2; 
                        w._origY2 = w.y2; 
                    });
                } else if (draggingObj.type === 'area') {
                    draggingObj._origPoints = draggingObj.points.map(p => ({x: p.x, y: p.y}));
                } else {
                    draggingObj._origX = draggingObj.x; 
                    draggingObj._origY = draggingObj.y;
                }
            }
        } else if (mode === 'area') {
            tempPoints.push({ x: pos.x, y: pos.y });
        } else if (mode === 'add') {
            addItemAtPosition(pos.x, pos.y);
        }
        draw();
    }

    function handleInteractionMove(pos) {
        if (mode === 'select' && draggingObj) {
            const dx = pos.x - startPos.x;
            const dy = pos.y - startPos.y;
            if (draggingObj.type === 'wall') {
                selectedWalls.forEach(w => {
                    w.x1 = w._origX1 + dx; 
                    w.y1 = w._origY1 + dy;
                    w.x2 = w._origX2 + dx; 
                    w.y2 = w._origY2 + dy;
                });
            } else if (draggingObj.type === 'area') {
                draggingObj.points = draggingObj._origPoints.map(p => ({ 
                    x: p.x + dx, 
                    y: p.y + dy 
                }));
            } else {
                draggingObj.x = draggingObj._origX + dx;
                draggingObj.y = draggingObj._origY + dy;
            }
        }
        draw();
    }

    function handleInteractionEnd() {
        if (mode === 'wall') {
            if (Math.abs(currentPos.x - startPos.x) > 5 || Math.abs(currentPos.y - startPos.y) > 5) {
                const activeLayer = getActiveLayer();
                activeLayer.objects.push({
                    id: nextId++,
                    type: 'wall',
                    x1: startPos.x, y1: startPos.y,
                    x2: currentPos.x, y2: currentPos.y,
                    thicknessType: currentWallThickness,
                    color: currentWallColor,
                    locked: false
                });
                updateCost();
                saveHistory();
            }
        } else if (mode === 'area') {
            // ã‚¨ãƒªã‚¢ä½œæˆã¯ã‚¿ãƒƒãƒ—ã§ç¶™ç¶š
        }
        draggingObj = null;
        draw();
    }

    function handleSelection(x, y) {
        deselect();
        const activeLayer = getActiveLayer();
        
        // å£ã®é¸æŠï¼ˆæ¥ç¶šã•ã‚ŒãŸå£ã‚‚é¸æŠï¼‰
        for (let obj of activeLayer.objects) {
            if (obj.type === 'wall') {
                const dist = distToSegment({ x, y }, { x: obj.x1, y: obj.y1 }, { x: obj.x2, y: obj.y2 });
                if (dist < 20 / camera.zoom) { // åˆ¤å®šç¯„å›²ã‚’æ‹¡å¤§
                    selectedObj = obj;
                    selectedWalls = [obj];
                    // æ¥ç¶šã•ã‚ŒãŸå£ã‚’æ¢ã™
                    findConnectedWalls(obj, activeLayer.objects);
                    showEditMenu();
                    draw();
                    return;
                }
            }
        }
        
        // ãã®ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆåˆ¤å®šã‚’ç·©å’Œï¼‰
        for (let obj of [...activeLayer.objects].reverse()) {
            if (obj.type === 'area' && isPointInPoly({ x, y }, obj.points)) {
                selectedObj = obj;
                showEditMenu();
                draw();
                return;
            } else if (obj.type !== 'wall' && obj.type !== 'area') {
                const w = (obj.w || 0) * GRID_UNIT;
                const h = (obj.h || 0) * GRID_UNIT;
                const margin = 10 / camera.zoom; // ãƒãƒ¼ã‚¸ãƒ³ã‚’è¿½åŠ 
                if (x >= obj.x - margin && x <= obj.x + w + margin && 
                    y >= obj.y - margin && y <= obj.y + h + margin) {
                    selectedObj = obj;
                    showEditMenu();
                    draw();
                    return;
                }
            }
        }
    }

    function findConnectedWalls(wall, objects) {
        const threshold = 5;
        const toCheck = [wall];
        const checked = new Set();
        
        while (toCheck.length > 0) {
            const current = toCheck.pop();
            if (checked.has(current.id)) continue;
            checked.add(current.id);
            
            for (let other of objects) {
                if (other.type !== 'wall' || checked.has(other.id)) continue;
                
                const connected = 
                    (Math.hypot(current.x1 - other.x1, current.y1 - other.y1) < threshold) ||
                    (Math.hypot(current.x1 - other.x2, current.y1 - other.y2) < threshold) ||
                    (Math.hypot(current.x2 - other.x1, current.y2 - other.y1) < threshold) ||
                    (Math.hypot(current.x2 - other.x2, current.y2 - other.y2) < threshold);
                
                if (connected) {
                    toCheck.push(other);
                    if (!selectedWalls.find(w => w.id === other.id)) {
                        selectedWalls.push(other);
                    }
                }
            }
        }
    }

    function showEditMenu() {
        const menu = document.getElementById('edit-menu');
        menu.style.display = 'flex';
        
        const lockBtn = document.getElementById('lock-btn');
        if (selectedObj.locked) {
            lockBtn.textContent = 'ğŸ”’ ãƒ­ãƒƒã‚¯è§£é™¤';
            lockBtn.classList.add('locked-btn');
        } else {
            lockBtn.textContent = 'ğŸ”“ ãƒ­ãƒƒã‚¯';
            lockBtn.classList.remove('locked-btn');
        }
        
        document.getElementById('select-label').textContent = 
            selectedObj.type === 'wall' ? `å£ (${selectedWalls.length}å€‹é¸æŠ)` : 
            selectedObj.label || selectedObj.areaType || 'é¸æŠä¸­';
    }

    function setMode(m, subtype = null) {
        mode = m;
        activeAreaType = subtype;
        activeItemType = null;
        eraserMode = (m === 'eraser');
        deselect();
        
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        
        if (m === 'select') {
            document.getElementById('btn-select').classList.add('active');
            canvas.style.cursor = 'default';
        } else if (m === 'eraser') {
            document.getElementById('btn-eraser').classList.add('active');
            canvas.style.cursor = 'crosshair';
        } else if (m === 'wall') {
            document.getElementById('btn-wall').classList.add('active');
            canvas.style.cursor = 'crosshair';
        } else if (m === 'area' && subtype === 'room') {
            document.getElementById('btn-area-room').classList.add('active');
            canvas.style.cursor = 'crosshair';
        } else if (m === 'area' && subtype === 'kitchen') {
            document.getElementById('btn-area-kitchen').classList.add('active');
            canvas.style.cursor = 'crosshair';
        } else {
            canvas.style.cursor = 'crosshair';
        }
        
        document.getElementById('status').innerText = 
            m === 'select' ? 'ãƒ¢ãƒ¼ãƒ‰: é¸æŠ/ç§»å‹•' :
            m === 'eraser' ? 'ãƒ¢ãƒ¼ãƒ‰: æ¶ˆã—ã‚´ãƒ ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒªãƒƒã‚¯ã§å‰Šé™¤ï¼‰' :
            m === 'wall' ? 'ãƒ¢ãƒ¼ãƒ‰: å£ã‚’æã' :
            m === 'area' ? `ãƒ¢ãƒ¼ãƒ‰: ${subtype}ã‚¨ãƒªã‚¢ã‚’ä½œæˆ` :
            'ãƒ¢ãƒ¼ãƒ‰: ã‚¢ã‚¤ãƒ†ãƒ é…ç½®';
    }

    function setWallThickness(type) {
        currentWallThickness = type;
        document.getElementById('btn-wall-outer').classList.toggle('active', type === 'outer');
        document.getElementById('btn-wall-inner').classList.toggle('active', type === 'inner');
    }

    function setAddItem(itemType) {
        mode = 'add';
        activeItemType = itemType;
        deselect();
        document.getElementById('status').innerText = `ãƒ¢ãƒ¼ãƒ‰: ${itemType}ã‚’é…ç½®`;
    }

    function addItemAtPosition(x, y) {
        const activeLayer = getActiveLayer();
        const items = {
            door: { w: 4, h: 1, color: 'rgba(231,76,60,0.3)', label: 'ãƒ‰ã‚¢' },
            window: { w: 3, h: 1, color: 'rgba(52,152,219,0.4)', label: 'çª“' },
            stair: { w: 5, h: 8, color: 'rgba(149,165,166,0.5)', label: 'éšæ®µ' },
            pillar: { w: 2, h: 2, color: 'rgba(44,62,80,0.8)', label: 'æŸ±' },
            bath100: { w: 8, h: 8, color: 'rgba(52,152,219,0.3)', label: 'é¢¨å‘‚' },
            toilet: { w: 4, h: 4, color: 'rgba(155,89,182,0.3)', label: 'ãƒˆã‚¤ãƒ¬' },
            bed: { w: 8, h: 10, color: 'rgba(243,156,18,0.3)', label: 'ãƒ™ãƒƒãƒ‰' },
            dining: { w: 8, h: 8, color: 'rgba(230,126,34,0.3)', label: 'ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°' }
        };
        
        if (items[activeItemType]) {
            activeLayer.objects.push({
                id: nextId++,
                type: activeItemType,
                x, y,
                ...items[activeItemType],
                rotation: 0,
                locked: false
            });
            updateCost();
            saveHistory();
            draw();
        }
    }

    // Undo/Redoæ©Ÿèƒ½
    function saveHistory() {
        // ç¾åœ¨ä½ç½®ã‚ˆã‚Šå¾Œã®å±¥æ­´ã‚’å‰Šé™¤
        history = history.slice(0, historyIndex + 1);
        
        // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
        const snapshot = JSON.parse(JSON.stringify(data));
        history.push(snapshot);
        
        // å±¥æ­´ã®ä¸Šé™ã‚’è¶…ãˆãŸã‚‰å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
        if (history.length > MAX_HISTORY) {
            history.shift();
        } else {
            historyIndex++;
        }
        
        updateUndoRedoButtons();
    }

    function undo() {
        if (historyIndex > 0) {
            historyIndex--;
            data = JSON.parse(JSON.stringify(history[historyIndex]));
            updateLayerList();
            updateCost();
            deselect();
            updateUndoRedoButtons();
        }
    }

    function redo() {
        if (historyIndex < history.length - 1) {
            historyIndex++;
            data = JSON.parse(JSON.stringify(history[historyIndex]));
            updateLayerList();
            updateCost();
            deselect();
            updateUndoRedoButtons();
        }
    }

    function updateUndoRedoButtons() {
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        
        if (undoBtn) undoBtn.disabled = historyIndex <= 0;
        if (redoBtn) redoBtn.disabled = historyIndex >= history.length - 1;
    }

    function onKeyDown(e) {
        // Ctrl+Z ã¾ãŸã¯ Cmd+Z ã§ Undo
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            undo();
        }
        // Ctrl+Y ã¾ãŸã¯ Ctrl+Shift+Z ã¾ãŸã¯ Cmd+Shift+Z ã§ Redo
        else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
            e.preventDefault();
            redo();
        }
        // Delete ã¾ãŸã¯ Backspace ã§å‰Šé™¤
        else if ((e.key === 'Delete' || e.key === 'Backspace') && selectedObj) {
            e.preventDefault();
            deleteObject();
        }
        // Escape ã§é¸æŠè§£é™¤
        else if (e.key === 'Escape') {
            e.preventDefault();
            deselect();
        }
    }

    // ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
    function getActiveLayer() {
        return data[currentFloor].layers.find(l => l.id === data[currentFloor].activeLayer);
    }

    function updateLayerList() {
        const list = document.getElementById('layer-list');
        list.innerHTML = '';
        
        data[currentFloor].layers.forEach((layer, idx) => {
            const item = document.createElement('div');
            item.className = 'layer-item' + (layer.id === data[currentFloor].activeLayer ? ' active' : '');
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'layer-checkbox';
            checkbox.checked = layer.visible;
            checkbox.onchange = () => {
                layer.visible = checkbox.checked;
                draw();
            };
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'layer-name';
            nameSpan.textContent = layer.name;
            nameSpan.ondblclick = () => {
                const newName = prompt('ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’å…¥åŠ›', layer.name);
                if (newName) {
                    layer.name = newName;
                    updateLayerList();
                }
            };
            
            const opacitySlider = document.createElement('input');
            opacitySlider.type = 'range';
            opacitySlider.className = 'layer-opacity';
            opacitySlider.min = '0';
            opacitySlider.max = '100';
            opacitySlider.value = layer.opacity * 100;
            opacitySlider.oninput = () => {
                layer.opacity = opacitySlider.value / 100;
                draw();
            };
            
            item.appendChild(checkbox);
            item.appendChild(nameSpan);
            item.appendChild(opacitySlider);
            
            item.onclick = (e) => {
                if (e.target !== checkbox && e.target !== opacitySlider) {
                    data[currentFloor].activeLayer = layer.id;
                    updateLayerList();
                    draw();
                }
            };
            
            list.appendChild(item);
        });
    }

    function addLayer() {
        const newId = 'layer' + Date.now();
        const newLayer = {
            id: newId,
            name: `ãƒ¬ã‚¤ãƒ¤ãƒ¼${data[currentFloor].layers.length + 1}`,
            visible: true,
            opacity: 1.0,
            objects: []
        };
        data[currentFloor].layers.push(newLayer);
        data[currentFloor].activeLayer = newId;
        updateLayerList();
        saveHistory();
        draw();
    }

    // å£ã®è‰²å¤‰æ›´
    function updateWallColorPreview() {
        const preset = document.getElementById('wall-color-preset');
        const custom = document.getElementById('wall-color-custom');
        const preview = document.getElementById('wall-color-preview');
        
        if (preset.value === 'custom') {
            custom.style.display = 'block';
            currentWallColor = custom.value;
        } else {
            custom.style.display = 'none';
            currentWallColor = preset.value;
        }
        preview.style.background = currentWallColor;
    }

    function changeWallColor() {
        if (!selectedObj) return;
        
        if (selectedObj.type === 'wall') {
            selectedWalls.forEach(w => {
                w.color = currentWallColor;
            });
        }
        saveHistory();
        draw();
    }

    // ãƒ­ãƒƒã‚¯æ©Ÿèƒ½
    function toggleLock() {
        if (!selectedObj) return;
        
        if (selectedObj.type === 'wall') {
            selectedWalls.forEach(w => {
                w.locked = !selectedObj.locked;
            });
        }
        selectedObj.locked = !selectedObj.locked;
        showEditMenu();
        saveHistory();
        draw();
    }

    // æ¡å…‰ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    function toggleLighting() {
        showLighting = document.getElementById('show-lighting').checked;
        draw();
    }

    function calculateLighting() {
        // ç°¡æ˜“çš„ãªæ¡å…‰ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        // çª“ã®ä½ç½®ã‹ã‚‰å…‰ãŒåºƒãŒã‚‹æ§˜å­ã‚’è¡¨ç¾
        const windows = [];
        data[currentFloor].layers.forEach(layer => {
            if (layer.visible) {
                layer.objects.forEach(obj => {
                    if (obj.type === 'window') {
                        windows.push(obj);
                    }
                });
            }
        });
        
        return windows;
    }

    // æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
    function checkAlignment() {
        const warnings = [];
        
        // 1Fã¨2Fã®å£ãƒ»æŸ±ã®æ•´åˆæ€§ã‚’ãƒã‚§ãƒƒã‚¯
        const f1Walls = [];
        const f2Walls = [];
        const f1Pillars = [];
        const f2Pillars = [];
        
        data[1].layers.forEach(layer => {
            layer.objects.forEach(obj => {
                if (obj.type === 'wall') f1Walls.push(obj);
                if (obj.type === 'pillar') f1Pillars.push(obj);
            });
        });
        
        data[2].layers.forEach(layer => {
            layer.objects.forEach(obj => {
                if (obj.type === 'wall') f2Walls.push(obj);
                if (obj.type === 'pillar') f2Pillars.push(obj);
            });
        });
        
        // 2Fã®ä¸»è¦ãªå£ãŒ1Fã§æ”¯ãˆã‚‰ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        f2Walls.forEach(w2 => {
            if (w2.thicknessType === 'outer') {
                let supported = false;
                const threshold = 50; // è¨±å®¹ç¯„å›²
                
                f1Walls.forEach(w1 => {
                    const overlap = checkWallOverlap(w1, w2, threshold);
                    if (overlap > 0.5) { // 50%ä»¥ä¸Šé‡ãªã£ã¦ã„ã‚Œã°OK
                        supported = true;
                    }
                });
                
                if (!supported) {
                    warnings.push(`2Fã®å£(${Math.round(w2.x1)},${Math.round(w2.y1)})ãŒ1Fã§æ”¯ãˆã‚‰ã‚Œã¦ã„ã¾ã›ã‚“`);
                }
            }
        });
        
        // 2Fã®æŸ±ãŒ1Fã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        f2Pillars.forEach(p2 => {
            let supported = false;
            const threshold = 30;
            
            f1Pillars.forEach(p1 => {
                if (Math.hypot(p1.x - p2.x, p1.y - p2.y) < threshold) {
                    supported = true;
                }
            });
            
            if (!supported) {
                warnings.push(`2Fã®æŸ±(${Math.round(p2.x)},${Math.round(p2.y)})ãŒ1Fã«ã‚ã‚Šã¾ã›ã‚“`);
            }
        });
        
        // è­¦å‘Šè¡¨ç¤º
        const warningPanel = document.getElementById('warning-panel');
        const warningList = document.getElementById('warning-list');
        
        if (warnings.length > 0) {
            warningList.innerHTML = warnings.map(w => `<div class="warning-item">â€¢ ${w}</div>`).join('');
            warningPanel.style.display = 'block';
            setTimeout(() => {
                warningPanel.style.display = 'none';
            }, 10000);
        } else {
            alert('æ•´åˆæ€§ã®å•é¡Œã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸï¼');
        }
    }

    function checkWallOverlap(w1, w2, threshold) {
        // 2ã¤ã®å£ã®é‡ãªã‚Šå…·åˆã‚’è¨ˆç®—ï¼ˆ0ï½1ï¼‰
        const len1 = Math.hypot(w1.x2 - w1.x1, w1.y2 - w1.y1);
        const len2 = Math.hypot(w2.x2 - w2.x1, w2.y2 - w2.y1);
        
        // ç°¡æ˜“çš„ãªé‡ãªã‚Šåˆ¤å®š
        const dist1 = distToSegment({x: w2.x1, y: w2.y1}, {x: w1.x1, y: w1.y1}, {x: w1.x2, y: w1.y2});
        const dist2 = distToSegment({x: w2.x2, y: w2.y2}, {x: w1.x1, y: w1.y1}, {x: w1.x2, y: w1.y2});
        
        if (dist1 < threshold && dist2 < threshold) {
            return 1.0; // ã»ã¼å®Œå…¨ã«é‡ãªã£ã¦ã„ã‚‹
        } else if (dist1 < threshold || dist2 < threshold) {
            return 0.5; // éƒ¨åˆ†çš„ã«é‡ãªã£ã¦ã„ã‚‹
        }
        return 0;
    }

    // è¨ˆç®—æ©Ÿèƒ½
    function calcPolygonAreaM2(points) {
        let areaPx = 0;
        for(let i=0, j=points.length-1; i<points.length; j=i++) {
            areaPx += (points[j].x + points[i].x) * (points[j].y - points[i].y);
        }
        let areaGridSq = Math.abs(areaPx / 2) / (GRID_UNIT * GRID_UNIT);
        return areaGridSq * (REAL_M_PER_GRID * REAL_M_PER_GRID);
    }

    function updateCost() {
        let totalCost = 0;
        [1, 2].forEach(floor => {
            data[floor].layers.forEach(layer => {
                layer.objects.forEach(o => {
                    if (o.type === 'wall') {
                        let lenM = (Math.hypot(o.x2 - o.x1, o.y2 - o.y1) / GRID_UNIT) * REAL_M_PER_GRID;
                        totalCost += lenM * 1.5;
                    } else if (o.type === 'area') {
                        let m2 = calcPolygonAreaM2(o.points);
                        totalCost += m2 * 20;
                    }
                });
            });
        });
        document.getElementById('cost-display').innerText = `æ¦‚ç®—ã‚³ã‚¹ãƒˆ: ç´„ ${Math.round(totalCost).toLocaleString()} ä¸‡å††`;
    }

    // æç”»å‡¦ç†
    function draw() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.translate(camera.x, camera.y);
        ctx.scale(camera.zoom, camera.zoom);

        // ã‚°ãƒªãƒƒãƒ‰
        if (document.getElementById('show-grid').checked) {
            ctx.strokeStyle = '#eee';
            for(let i=-2000; i<3000; i+=GRID_UNIT){
                ctx.beginPath(); 
                ctx.lineWidth = (i%(GRID_UNIT*4)===0 ? 1 : 0.3) / camera.zoom;
                ctx.moveTo(i,-2000); ctx.lineTo(i,3000); ctx.stroke();
                ctx.beginPath(); 
                ctx.moveTo(-2000,i); ctx.lineTo(3000,i); ctx.stroke();
            }
        }

        // ä¸‹éšã®è¡¨ç¤ºï¼ˆ2Fç·¨é›†æ™‚ï¼‰
        if (currentFloor === 2) {
            ctx.globalAlpha = 0.15;
            data[1].layers.forEach(layer => {
                if (layer.visible) {
                    layer.objects.forEach(renderObj);
                }
            });
            ctx.globalAlpha = 1.0;
        }

        // æ¡å…‰ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        if (showLighting) {
            const windows = calculateLighting();
            windows.forEach(win => {
                const gradient = ctx.createRadialGradient(
                    win.x + (win.w * GRID_UNIT) / 2,
                    win.y + (win.h * GRID_UNIT) / 2,
                    0,
                    win.x + (win.w * GRID_UNIT) / 2,
                    win.y + (win.h * GRID_UNIT) / 2,
                    200
                );
                gradient.addColorStop(0, 'rgba(255, 247, 153, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 247, 153, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(win.x - 200, win.y - 200, 400, 400);
            });
        }

        // ç¾åœ¨ã®ãƒ•ãƒ­ã‚¢ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æç”»
        data[currentFloor].layers.forEach(layer => {
            if (layer.visible) {
                ctx.globalAlpha = layer.opacity;
                layer.objects.forEach(renderObj);
                ctx.globalAlpha = 1.0;
            }
        });

        // å¤–å‘¨å¯¸æ³•ã®è¡¨ç¤º
        if (document.getElementById('show-dimensions').checked) {
            drawOuterDimensions();
        }

        // ä½œæ¥­ä¸­è¡¨ç¤º
        if (mode === 'wall' && isDragging) {
            ctx.strokeStyle = currentWallColor; 
            ctx.lineWidth = (currentWallThickness === 'outer' ? 8 : 4) / camera.zoom;
            ctx.beginPath(); 
            ctx.moveTo(startPos.x, startPos.y); 
            ctx.lineTo(currentPos.x, currentPos.y); 
            ctx.stroke();
        }
        if (tempPoints.length > 0) {
            ctx.strokeStyle = '#e74c3c'; 
            ctx.lineWidth = 2 / camera.zoom;
            ctx.beginPath();
            tempPoints.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.lineTo(currentPos.x, currentPos.y);
            ctx.stroke();
            ctx.fillStyle = 'red';
            ctx.beginPath(); 
            ctx.arc(tempPoints[0].x, tempPoints[0].y, 8/camera.zoom, 0, Math.PI*2); 
            ctx.fill();
        }
    }

    function renderObj(o) {
        ctx.save();
        const isSelected = selectedObj && (selectedObj.id === o.id || (o.type === 'wall' && selectedWalls.some(w => w.id === o.id)));
        
        if (o.type === 'wall') {
            ctx.strokeStyle = o.locked ? '#f39c12' : (isSelected ? 'red' : (o.color || '#333'));
            ctx.lineWidth = (o.thicknessType === 'inner' ? 4 : 8) / camera.zoom;
            ctx.lineCap = 'round';
            ctx.beginPath(); 
            ctx.moveTo(o.x1, o.y1); 
            ctx.lineTo(o.x2, o.y2); 
            ctx.stroke();
            
            if (o.locked) {
                // ãƒ­ãƒƒã‚¯ã‚¢ã‚¤ã‚³ãƒ³è¡¨ç¤º
                const mx = (o.x1 + o.x2) / 2;
                const my = (o.y1 + o.y2) / 2;
                ctx.fillStyle = '#f39c12';
                ctx.font = `${12/camera.zoom}px sans-serif`;
                ctx.fillText('ğŸ”’', mx, my);
            }
            
        } else if (o.type === 'area') {
            ctx.fillStyle = o.color;
            ctx.beginPath();
            o.points.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.closePath(); 
            ctx.fill();
            ctx.strokeStyle = isSelected ? 'red' : '#7f8c8d';
            ctx.lineWidth = 2 / camera.zoom; 
            ctx.stroke();

            let cx = 0, cy = 0;
            o.points.forEach(p => { cx += p.x; cy += p.y; });
            cx /= o.points.length; cy /= o.points.length;
            
            let m2 = calcPolygonAreaM2(o.points);
            let jou = m2 / 1.62;
            
            ctx.fillStyle = '#333'; 
            ctx.font = `bold ${12/camera.zoom}px sans-serif`; 
            ctx.textAlign = 'center';
            ctx.fillText(`${m2.toFixed(1)}ã¡ (${jou.toFixed(1)}å¸–)`, cx, cy);

        } else if (o.type === 'door') {
            ctx.translate(o.x, o.y); 
            ctx.rotate(o.rotation * Math.PI / 180);
            ctx.strokeStyle = isSelected ? 'red' : '#e74c3c'; 
            ctx.lineWidth = 3 / camera.zoom;
            const size = o.w * GRID_UNIT;
            ctx.beginPath(); 
            ctx.moveTo(0,0); 
            ctx.lineTo(0, size); 
            ctx.stroke();
            ctx.setLineDash([5, 5]);
            ctx.beginPath(); 
            ctx.arc(0, 0, size, Math.PI/2, 0, true); 
            ctx.stroke();
            ctx.setLineDash([]);
            
        } else if (o.type === 'window') {
            ctx.translate(o.x, o.y); 
            ctx.rotate(o.rotation * Math.PI / 180);
            ctx.fillStyle = o.color; 
            ctx.strokeStyle = isSelected ? 'red' : '#3498db';
            ctx.lineWidth = 2 / camera.zoom;
            ctx.fillRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            ctx.strokeRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            // çª“ã‚¬ãƒ©ã‚¹ã®è¡¨ç¾
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 1 / camera.zoom;
            ctx.beginPath();
            ctx.moveTo(o.w * GRID_UNIT / 2, 0);
            ctx.lineTo(o.w * GRID_UNIT / 2, o.h * GRID_UNIT);
            ctx.stroke();
            
        } else if (o.type === 'pillar') {
            ctx.translate(o.x, o.y);
            ctx.fillStyle = o.locked ? '#f39c12' : (o.color || 'rgba(44,62,80,0.8)');
            ctx.strokeStyle = isSelected ? 'red' : '#333';
            ctx.lineWidth = 2 / camera.zoom;
            ctx.fillRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            ctx.strokeRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            
            if (o.locked) {
                ctx.fillStyle = '#fff';
                ctx.font = `${10/camera.zoom}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ”’', (o.w * GRID_UNIT)/2, (o.h * GRID_UNIT)/2);
            }
            
        } else {
            ctx.translate(o.x, o.y); 
            ctx.rotate(o.rotation * Math.PI / 180);
            ctx.fillStyle = o.color; 
            ctx.strokeStyle = isSelected ? 'red' : '#333';
            ctx.lineWidth = 2 / camera.zoom;
            ctx.fillRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            ctx.strokeRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            ctx.fillStyle = '#000'; 
            ctx.font = `${10/camera.zoom}px sans-serif`; 
            ctx.textAlign = 'center';
            ctx.fillText(o.label, (o.w * GRID_UNIT)/2, (o.h * GRID_UNIT)/2 + 3/camera.zoom);
        }
        ctx.restore();
    }

    function drawOuterDimensions() {
        // å¤–å‘¨ã®å£ã‚’æ¤œå‡ºã—ã¦å¯¸æ³•ã‚’è¡¨ç¤º
        const walls = [];
        data[currentFloor].layers.forEach(layer => {
            if (layer.visible) {
                layer.objects.forEach(obj => {
                    if (obj.type === 'wall' && obj.thicknessType === 'outer') {
                        walls.push(obj);
                    }
                });
            }
        });
        
        // å£ã‚’çµåˆã—ã¦ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆ
        const segments = mergeConnectedWalls(walls);
        
        segments.forEach(seg => {
            const mx = (seg.x1 + seg.x2) / 2;
            const my = (seg.y1 + seg.y2) / 2;
            const lenGrid = Math.hypot(seg.x2 - seg.x1, seg.y2 - seg.y1) / GRID_UNIT;
            const lenM = lenGrid * REAL_M_PER_GRID;
            
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(mx - 25, my - 10, 50, 20);
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${10/camera.zoom}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${lenM.toFixed(2)}m`, mx, my);
            ctx.restore();
        });
    }

    function mergeConnectedWalls(walls) {
        if (walls.length === 0) return [];
        
        const segments = [];
        const used = new Set();
        
        walls.forEach((wall, idx) => {
            if (used.has(idx)) return;
            
            let current = { x1: wall.x1, y1: wall.y1, x2: wall.x2, y2: wall.y2 };
            used.add(idx);
            
            // åŒã˜ç›´ç·šä¸Šã«ã‚ã‚‹å£ã‚’çµåˆ
            let merged = true;
            while (merged) {
                merged = false;
                for (let i = 0; i < walls.length; i++) {
                    if (used.has(i)) continue;
                    
                    const other = walls[i];
                    const threshold = 5;
                    
                    // ç›´ç·šä¸Šã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    const angle1 = Math.atan2(current.y2 - current.y1, current.x2 - current.x1);
                    const angle2 = Math.atan2(other.y2 - other.y1, other.x2 - other.x1);
                    const angleDiff = Math.abs(angle1 - angle2);
                    
                    if (angleDiff < 0.1 || Math.abs(angleDiff - Math.PI) < 0.1) {
                        // æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        if (Math.hypot(current.x2 - other.x1, current.y2 - other.y1) < threshold) {
                            current.x2 = other.x2;
                            current.y2 = other.y2;
                            used.add(i);
                            merged = true;
                            break;
                        } else if (Math.hypot(current.x2 - other.x2, current.y2 - other.y2) < threshold) {
                            current.x2 = other.x1;
                            current.y2 = other.y1;
                            used.add(i);
                            merged = true;
                            break;
                        } else if (Math.hypot(current.x1 - other.x1, current.y1 - other.y1) < threshold) {
                            current.x1 = other.x2;
                            current.y1 = other.y2;
                            used.add(i);
                            merged = true;
                            break;
                        } else if (Math.hypot(current.x1 - other.x2, current.y1 - other.y2) < threshold) {
                            current.x1 = other.x1;
                            current.y1 = other.y1;
                            used.add(i);
                            merged = true;
                            break;
                        }
                    }
                }
            }
            
            segments.push(current);
        });
        
        return segments;
    }

    // æ•°å­¦ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    function distToSegment(p, v, w) {
        const l2 = Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
        if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
    }
    
    function isPointInPoly(p, poly) {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            if (((poly[i].y > p.y) !== (poly[j].y > p.y)) && (p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) inside = !inside;
        }
        return inside;
    }

    // UIã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
    function rotateObject() { 
        if(!selectedObj) return;
        
        if (selectedObj.locked) return;
        
        if (selectedObj.type === 'wall' && selectedWalls.length > 0) {
            // å£ã®å›è»¢ï¼ˆä¸­å¿ƒç‚¹ã‚’åŸºæº–ã«90åº¦å›è»¢ï¼‰
            const centerX = selectedWalls.reduce((sum, w) => sum + w.x1 + w.x2, 0) / (selectedWalls.length * 2);
            const centerY = selectedWalls.reduce((sum, w) => sum + w.y1 + w.y2, 0) / (selectedWalls.length * 2);
            
            selectedWalls.forEach(w => {
                const x1 = w.x1 - centerX;
                const y1 = w.y1 - centerY;
                const x2 = w.x2 - centerX;
                const y2 = w.y2 - centerY;
                
                // 90åº¦å›è»¢
                w.x1 = -y1 + centerX;
                w.y1 = x1 + centerY;
                w.x2 = -y2 + centerX;
                w.y2 = x2 + centerY;
            });
            saveHistory();
            draw();
        } else if (selectedObj.type !== 'wall') {
            selectedObj.rotation = (selectedObj.rotation + 90) % 360; 
            saveHistory();
            draw(); 
        }
    }
    
    function changeSize(dw, dh) { 
        if (selectedObj && selectedObj.w !== undefined && !selectedObj.locked) { 
            selectedObj.w = Math.max(2, selectedObj.w + dw); 
            selectedObj.h = Math.max(2, selectedObj.h + dh); 
            saveHistory();
            draw(); 
        } 
    }
    
    function deleteObject() { 
        if(selectedObj) {
            if (selectedObj.locked) {
                alert('ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å‰Šé™¤ã§ãã¾ã›ã‚“');
                return;
            }
            
            const activeLayer = getActiveLayer();
            if (selectedObj.type === 'wall' && selectedWalls.length > 0) {
                const idsToRemove = selectedWalls.map(w => w.id);
                activeLayer.objects = activeLayer.objects.filter(o => !idsToRemove.includes(o.id));
            } else {
                activeLayer.objects = activeLayer.objects.filter(o => o.id !== selectedObj.id); 
            }
            updateCost(); 
            saveHistory();
            deselect(); 
        } 
    }
    
    function deselect() { 
        selectedObj = null; 
        selectedWalls = []; 
        document.getElementById('edit-menu').style.display = 'none'; 
        draw(); 
    }
    
    function changeFloor(f) { 
        currentFloor = f; 
        document.getElementById('f1-btn').classList.toggle('active', f===1); 
        document.getElementById('f2-btn').classList.toggle('active', f===2); 
        updateLayerList();
        deselect(); 
    }
    
    function resetView() { 
        camera = { x: 0, y: 0, zoom: 1.0 }; 
        document.getElementById('zoom-info').innerText = 'ã‚ºãƒ¼ãƒ : 100%';
        draw(); 
    }

    function saveData() { 
        localStorage.setItem('madori_planner_data_v2', JSON.stringify(data)); 
        alert('ä¿å­˜ã—ã¾ã—ãŸ'); 
    }
    
    function loadData() { 
        const saved = localStorage.getItem('madori_planner_data_v2'); 
        if (saved) { 
            data = JSON.parse(saved); 
            updateLayerList();
            updateCost(); 
            deselect(); 
            alert('èª­è¾¼ã—ã¾ã—ãŸ'); 
        } else {
            alert('ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
        }
    }

    // ã‚¨ãƒªã‚¢ä½œæˆã®å®Œäº†å‡¦ç†ï¼ˆãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã¾ãŸã¯é–‹å§‹ç‚¹ã«è¿‘ã¥ãï¼‰
    canvas.addEventListener('dblclick', (e) => {
        if (mode === 'area' && tempPoints.length >= 3) {
            const activeLayer = getActiveLayer();
            const colors = {
                room: 'rgba(46,204,113,0.3)',
                kitchen: 'rgba(241,196,15,0.3)'
            };
            activeLayer.objects.push({
                id: nextId++,
                type: 'area',
                areaType: activeAreaType,
                points: [...tempPoints],
                color: colors[activeAreaType] || 'rgba(149,165,166,0.3)',
                locked: false
            });
            tempPoints = [];
            updateCost();
            saveHistory();
            draw();
        }
    });

    init();
</script>
</body>
</html>
