<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é–“å–ã‚ŠPlanner Pro Custom</title>
    <style>
        :root { --primary: #2c3e50; --accent: #e74c3c; --ui-bg: rgba(255,255,255,0.9); }
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #ddd; touch-action: none; }
        canvas { display: block; background: #fff; }

        .ui-panel { position: fixed; background: var(--ui-bg); backdrop-filter: blur(5px); z-index: 100; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #top-bar { top: 10px; left: 10px; right: 10px; height: 50px; display: flex; align-items: center; justify-content: space-between; padding: 0 10px; gap: 5px; }
        
        #toolbar { bottom: 0; left: 0; width: 100%; display: flex; flex-direction: column; padding-bottom: max(10px, env(safe-area-inset-bottom)); }
        .scroll-menu { display: flex; overflow-x: auto; padding: 10px; gap: 8px; }
        
        button.tool-btn { 
            flex: 0 0 auto; padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; background: white; font-size: 11px; display: flex; flex-direction: column; align-items: center; min-width: 60px;
        }
        button.tool-btn.active { background: #e3f2fd; border-color: var(--primary); font-weight: bold; }

        /* ç·¨é›†ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ãƒœã‚¿ãƒ³ãŒå¢—ãˆã‚‹ãŸã‚æŠ˜ã‚Šè¿”ã—å¯¾å¿œ */
        #edit-menu { display: none; position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%); padding: 10px; gap: 8px; background: var(--primary); color: white; flex-wrap: wrap; justify-content: center; width: max-content; max-width: 90%; }
        #edit-menu button { background: none; border: 1px solid white; color: white; padding: 5px 10px; border-radius: 4px; font-size: 12px; }
        
        .floor-btn { padding: 5px 15px; border: 1px solid #ccc; background: #fff; border-radius: 20px; }
        .floor-btn.active { background: var(--primary); color: white; }
        #zoom-info { position: fixed; top: 70px; right: 20px; font-size: 10px; color: #666; background: rgba(255,255,255,0.7); padding: 2px 5px; border-radius: 4px; }
        
        .top-btn-group button { font-size: 11px; padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; background: #fff; }
    </style>
</head>
<body>

<div id="top-bar" class="ui-panel">
    <div>
        <button class="floor-btn active" id="f1-btn" onclick="changeFloor(1)">1F</button>
        <button class="floor-btn" id="f2-btn" onclick="changeFloor(2)">2F</button>
    </div>
    <div id="status" style="font-size:11px; flex-grow:1; text-align:center;">ãƒ¢ãƒ¼ãƒ‰: å£ã‚’æã</div>
    <div class="top-btn-group">
        <button onclick="saveData()">ä¿å­˜</button>
        <button onclick="loadData()">èª­è¾¼</button>
        <button onclick="resetView()">ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
</div>

<div id="zoom-info">ã‚ºãƒ¼ãƒ : 100% (äºŒæœ¬æŒ‡ã§æ‹¡å¤§ç¸®å°)</div>

<div id="edit-menu" class="ui-panel">
    <span id="select-label" style="font-size:10px; margin-right:5px; width:100%; text-align:center;"></span>
    <button id="btn-w-up" onclick="changeSize(2, 0)">å¹…+</button>
    <button id="btn-w-down" onclick="changeSize(-2, 0)">å¹…-</button>
    <button id="btn-h-up" onclick="changeSize(0, 2)">é•·+</button>
    <button id="btn-h-down" onclick="changeSize(0, -2)">é•·-</button>
    <button onclick="rotateObject()">âŸ³ å›è»¢</button>
    <button onclick="deleteObject()" style="color:#ffadad;">ğŸ—‘ å‰Šé™¤</button>
    <button onclick="deselect()">Ã— é–‰ã˜ã‚‹</button>
</div>

<canvas id="canvas"></canvas>

<div id="toolbar" class="ui-panel">
    <div class="scroll-menu">
        <button id="btn-wall" class="tool-btn active" onclick="setMode('wall')">ğŸ§±<span>å£</span></button>
        <button id="btn-area-kitchen" class="tool-btn" onclick="setMode('area', 'kitchen')">ğŸ³<span>ã‚­ãƒƒãƒãƒ³ã‚¹ãƒšãƒ¼ã‚¹</span></button>
        <button id="btn-area-void" class="tool-btn" onclick="setMode('area', 'void')">ğŸ•³<span>å¹ãæŠœã‘ç¯„å›²</span></button>
        <button id="btn-select" class="tool-btn" onclick="setMode('select')">ğŸ‘†<span>é¸æŠ/ç§»å‹•</span></button>
        <button class="tool-btn" onclick="setAddItem('door')">ğŸšª<span>ãƒ‰ã‚¢</span></button>
        <button class="tool-btn" onclick="setAddItem('stair')">ğŸªœ<span>éšæ®µ</span></button>
        <button class="tool-btn" onclick="setAddItem('bath100')">ğŸ›<span>é¢¨å‘‚1åª</span></button>
        <button class="tool-btn" onclick="setAddItem('toilet')">ğŸš½<span>ãƒˆã‚¤ãƒ¬</span></button>
    </div>
</div>

<script>
    const GRID_UNIT = 20;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let data = { 1: { objects: [] }, 2: { objects: [] } };
    let currentFloor = 1;
    let mode = 'wall'; 
    let activeAreaType = null;
    let activeItemType = null;
    let selectedObj = null;
    let selectedWalls = []; // ä¸€ä½“åŒ–ã—ãŸå£ã®ç®¡ç†ç”¨
    let draggingObj = null; // ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•ä¸­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

    let camera = { x: 0, y: 0, zoom: 1.0 };
    let isDragging = false, isPinching = false;
    let lastTouch = { x: 0, y: 0 }, startDist = 0;
    
    let tempPoints = [];
    let startPos = {x:0, y:0}, currentPos = {x:0, y:0};

    function init() {
        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('touchstart', onTouchStart, {passive: false});
        canvas.addEventListener('touchmove', onTouchMove, {passive: false});
        canvas.addEventListener('touchend', onTouchEnd);
        draw();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        draw();
    }

    function screenToWorld(x, y) {
        return {
            x: (x - camera.x) / camera.zoom,
            y: (y - camera.y) / camera.zoom
        };
    }

    function snap(val) { return Math.round(val / GRID_UNIT) * GRID_UNIT; }

    function onTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 2) {
            isPinching = true;
            startDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
        } else {
            isDragging = true;
            const touch = e.touches[0];
            lastTouch = { x: touch.pageX, y: touch.pageY };
            
            const worldPos = screenToWorld(touch.pageX, touch.pageY);
            startPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
            currentPos = { ...startPos };

            if (mode === 'select') {
                handleSelection(startPos.x, startPos.y);
                if (selectedObj) {
                    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç§»å‹•é–‹å§‹æ™‚ã«å…ƒã®åº§æ¨™ã‚’è¨˜éŒ²
                    draggingObj = selectedObj;
                    if (draggingObj.type === 'wall') {
                        selectedWalls.forEach(w => {
                            w._origX1 = w.x1; w._origY1 = w.y1;
                            w._origX2 = w.x2; w._origY2 = w.y2;
                        });
                    } else if (draggingObj.type === 'area') {
                        draggingObj._origPoints = draggingObj.points.map(p => ({...p}));
                    } else {
                        draggingObj._origX = draggingObj.x;
                        draggingObj._origY = draggingObj.y;
                    }
                }
            } else if (mode === 'area') {
                tempPoints.push({ x: startPos.x, y: startPos.y });
                if (tempPoints.length > 2 && startPos.x === tempPoints[0].x && startPos.y === tempPoints[0].y) {
                    completeArea();
                }
            } else if (mode === 'add') {
                placeItem(startPos.x, startPos.y);
            }
        }
        draw();
    }

    function onTouchMove(e) {
        e.preventDefault();
        if (isPinching && e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            const delta = dist / startDist;
            camera.zoom = Math.min(Math.max(camera.zoom * delta, 0.5), 3.0);
            startDist = dist;
            document.getElementById('zoom-info').innerText = `ã‚ºãƒ¼ãƒ : ${Math.round(camera.zoom*100)}%`;
        } else if (isDragging) {
            const touch = e.touches[0];
            if (mode === 'select') {
                if (draggingObj) {
                    // é¸æŠã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¹ãƒŠãƒƒãƒ—ã—ãªãŒã‚‰ç§»å‹•
                    const worldPos = screenToWorld(touch.pageX, touch.pageY);
                    currentPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
                    const dx = currentPos.x - startPos.x;
                    const dy = currentPos.y - startPos.y;

                    if (draggingObj.type === 'wall') {
                        selectedWalls.forEach(w => {
                            w.x1 = w._origX1 + dx; w.y1 = w._origY1 + dy;
                            w.x2 = w._origX2 + dx; w.y2 = w._origY2 + dy;
                        });
                    } else if (draggingObj.type === 'area') {
                        draggingObj.points = draggingObj._origPoints.map(p => ({x: p.x + dx, y: p.y + dy}));
                    } else {
                        draggingObj.x = draggingObj._origX + dx;
                        draggingObj.y = draggingObj._origY + dy;
                    }
                } else {
                    camera.x += (touch.pageX - lastTouch.x);
                    camera.y += (touch.pageY - lastTouch.y);
                }
            } else {
                const worldPos = screenToWorld(touch.pageX, touch.pageY);
                currentPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
            }
            lastTouch = { x: touch.pageX, y: touch.pageY };
        }
        draw();
    }

    function onTouchEnd() {
        if (mode === 'wall' && isDragging) {
            if (startPos.x !== currentPos.x || startPos.y !== currentPos.y) {
                data[currentFloor].objects.push({
                    id: Date.now(), type: 'wall', x1: startPos.x, y1: startPos.y, x2: currentPos.x, y2: currentPos.y
                });
            }
        }
        isDragging = false;
        isPinching = false;
        draggingObj = null;
        draw();
    }

    // ç¹‹ãŒã£ã¦ã„ã‚‹å£ã‚’èŠ‹ã¥ã‚‹å¼ã«å–å¾—ï¼ˆä¸€ä½“åˆ¤å®šï¼‰
    function getConnectedWalls(startWall) {
        let connected = [startWall];
        let toCheck = [startWall];
        let checkedIds = new Set([startWall.id]);

        while(toCheck.length > 0) {
            let w = toCheck.pop();
            data[currentFloor].objects.forEach(o => {
                if (o.type === 'wall' && !checkedIds.has(o.id)) {
                    if (o.x1 === w.x1 && o.y1 === w.y1 || o.x1 === w.x2 && o.y1 === w.y2 ||
                        o.x2 === w.x1 && o.y2 === w.y1 || o.x2 === w.x2 && o.y2 === w.y2) {
                        connected.push(o);
                        toCheck.push(o);
                        checkedIds.add(o.id);
                    }
                }
            });
        }
        return connected;
    }

    function handleSelection(x, y) {
        const objs = data[currentFloor].objects;
        let found = null;
        for (let i = objs.length - 1; i >= 0; i--) {
            const o = objs[i];
            if (o.type === 'wall') {
                if (distToSegment({x, y}, {x:o.x1, y:o.y1}, {x:o.x2, y:o.y2}) < 15) found = o;
            } else if (o.type === 'area') {
                if (isPointInPoly({x,y}, o.points)) found = o;
            } else {
                // å¹…ã‚„é«˜ã•ã‚’è€ƒæ…®ã—ãŸå½“ãŸã‚Šåˆ¤å®š
                let cw = (o.w || 4) * GRID_UNIT;
                let ch = (o.h || 4) * GRID_UNIT;
                // ç°¡æ˜“çš„ã«å›è»¢éè€ƒæ…®ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã¨ã—ã¦åˆ¤å®š
                if (x >= o.x - cw/2 && x <= o.x + cw && y >= o.y - ch/2 && y <= o.y + ch) found = o;
            }
            if (found) break;
        }

        selectedObj = found;
        if (found) {
            if (found.type === 'wall') {
                selectedWalls = getConnectedWalls(found);
                document.getElementById('select-label').innerText = `é€£ç¶šå£ (${selectedWalls.length})`;
            } else {
                selectedWalls = [];
                document.getElementById('select-label').innerText = found.label || found.type;
            }

            // ã‚µã‚¤ã‚ºå¤‰æ›´ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆï¼ˆçŸ©å½¢ã‚„å»ºå…·ã®ã¿ï¼‰
            const isSizeable = (found.type !== 'wall' && found.type !== 'area');
            document.getElementById('btn-w-up').style.display = isSizeable ? 'inline-block' : 'none';
            document.getElementById('btn-w-down').style.display = isSizeable ? 'inline-block' : 'none';
            document.getElementById('btn-h-up').style.display = isSizeable ? 'inline-block' : 'none';
            document.getElementById('btn-h-down').style.display = isSizeable ? 'inline-block' : 'none';

            document.getElementById('edit-menu').style.display = 'flex';
        } else {
            deselect();
        }
    }

    function completeArea() {
        if (tempPoints.length < 3) return;
        data[currentFloor].objects.push({
            id: Date.now(), type: 'area', areaType: activeAreaType,
            points: [...tempPoints],
            color: activeAreaType === 'kitchen' ? 'rgba(243, 156, 18, 0.4)' : 'rgba(0,0,0,0.1)',
            isVoid: activeAreaType === 'void'
        });
        tempPoints = [];
        setMode('select');
    }

    function setMode(m, sub) {
        mode = m; activeAreaType = sub;
        tempPoints = [];
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        if (sub) document.getElementById('btn-area-'+sub).classList.add('active');
        else if (document.getElementById('btn-'+m)) document.getElementById('btn-'+m).classList.add('active');
        document.getElementById('status').innerText = `ãƒ¢ãƒ¼ãƒ‰: ${m} ${sub||''}`;
        deselect();
    }

    function setAddItem(type) {
        mode = 'add'; activeItemType = type;
        setMode('add');
        document.getElementById('status').innerText = `é…ç½®ãƒ¢ãƒ¼ãƒ‰: ${type}`;
    }

    function placeItem(x, y) {
        const presets = {
            'door': { w: 4, h: 4, type: 'door' },
            'stair': { w: 4, h: 8, type: 'rect', label: 'éšæ®µ', color: '#bdc3c7' },
            'bath100': { w: 8, h: 8, type: 'rect', label: 'é¢¨å‘‚', color: '#3498db' },
            'toilet': { w: 4, h: 6, type: 'rect', label: 'ãƒˆã‚¤ãƒ¬', color: '#1abc9c' } // ç¸¦é•·ã«ä¿®æ­£
        };
        const p = presets[activeItemType];
        data[currentFloor].objects.push({ ...p, id: Date.now(), x, y, rotation: 0 });
        setMode('select');
    }

    function draw() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.translate(camera.x, camera.y);
        ctx.scale(camera.zoom, camera.zoom);

        // ã‚°ãƒªãƒƒãƒ‰
        ctx.strokeStyle = '#eee';
        for(let i=-2000; i<3000; i+=GRID_UNIT){
            ctx.beginPath(); ctx.lineWidth=i%(GRID_UNIT*4)===0?1:0.3;
            ctx.moveTo(i,-2000); ctx.lineTo(i,3000); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-2000,i); ctx.lineTo(3000,i); ctx.stroke();
        }

        if (currentFloor === 2) {
            ctx.globalAlpha = 0.1;
            data[1].objects.forEach(renderObj);
            ctx.globalAlpha = 1.0;
        }
        data[currentFloor].objects.forEach(renderObj);

        if (mode === 'wall' && isDragging) {
            ctx.strokeStyle = '#3498db'; ctx.lineWidth = 5;
            ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(currentPos.x, currentPos.y); ctx.stroke();
        }
        if (tempPoints.length > 0) {
            ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 2;
            ctx.beginPath();
            tempPoints.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.lineTo(currentPos.x, currentPos.y);
            ctx.stroke();
            ctx.fillStyle = 'red';
            ctx.beginPath(); ctx.arc(tempPoints[0].x, tempPoints[0].y, 8/camera.zoom, 0, Math.PI*2); ctx.fill();
        }
    }

    function renderObj(o) {
        ctx.save();
        // é€£å‹•ã—ã¦ã„ã‚‹å£ã‚‚å«ã‚ã¦ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        const isSelected = selectedObj && (selectedObj.id === o.id || (o.type === 'wall' && selectedWalls.some(w => w.id === o.id)));
        
        if (o.type === 'wall') {
            ctx.strokeStyle = isSelected ? 'red' : '#333';
            ctx.lineWidth = 8; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(o.x1, o.y1); ctx.lineTo(o.x2, o.y2); ctx.stroke();
        } else if (o.type === 'area') {
            ctx.fillStyle = o.color;
            ctx.beginPath();
            o.points.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.closePath(); ctx.fill();
            ctx.strokeStyle = isSelected ? 'red' : '#7f8c8d';
            ctx.lineWidth = 2; ctx.stroke();
        } else if (o.type === 'door') {
            ctx.translate(o.x, o.y); ctx.rotate(o.rotation * Math.PI / 180);
            ctx.strokeStyle = isSelected ? 'red' : '#e74c3c'; ctx.lineWidth = 3;
            const size = o.w * GRID_UNIT;
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, size); ctx.stroke();
            ctx.setLineDash([5, 5]);
            ctx.beginPath(); ctx.arc(0, 0, size, Math.PI/2, 0, true); ctx.stroke();
        } else {
            ctx.translate(o.x, o.y); ctx.rotate(o.rotation * Math.PI / 180);
            ctx.fillStyle = o.color; ctx.strokeStyle = isSelected ? 'red' : '#333';
            ctx.fillRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            ctx.strokeRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            ctx.fillStyle = '#000'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
            ctx.fillText(o.label, (o.w * GRID_UNIT)/2, (o.h * GRID_UNIT)/2);
        }
        ctx.restore();
    }

    function distToSegment(p, v, w) {
        const l2 = Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
        if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
    }
    
    function isPointInPoly(p, poly) {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            if (((poly[i].y > p.y) !== (poly[j].y > p.y)) && (p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) inside = !inside;
        }
        return inside;
    }

    // å„ç¨®æ“ä½œ
    function rotateObject() { if(selectedObj && selectedObj.type !== 'wall') { selectedObj.rotation = (selectedObj.rotation + 90) % 360; draw(); } }
    
    function changeSize(dw, dh) {
        if (selectedObj && selectedObj.w !== undefined) {
            selectedObj.w = Math.max(2, selectedObj.w + dw); // æœ€å°å¹…ã¯2ã‚°ãƒªãƒƒãƒ‰
            selectedObj.h = Math.max(2, selectedObj.h + dh);
            draw();
        }
    }

    function deleteObject() { 
        if(selectedObj) { 
            if (selectedObj.type === 'wall' && selectedWalls.length > 0) {
                // é€£å‹•ã—ã¦ã„ã‚‹å£ã‚’å…¨ã¦å‰Šé™¤
                const idsToRemove = selectedWalls.map(w => w.id);
                data[currentFloor].objects = data[currentFloor].objects.filter(o => !idsToRemove.includes(o.id));
            } else {
                data[currentFloor].objects = data[currentFloor].objects.filter(o => o.id !== selectedObj.id); 
            }
            deselect(); 
        } 
    }
    
    function deselect() { selectedObj = null; selectedWalls = []; document.getElementById('edit-menu').style.display = 'none'; draw(); }
    function changeFloor(f) { currentFloor = f; document.getElementById('f1-btn').classList.toggle('active', f===1); document.getElementById('f2-btn').classList.toggle('active', f===2); deselect(); }
    function resetView() { camera = { x: 0, y: 0, zoom: 1.0 }; draw(); }

    // ä¿å­˜ã¨èª­è¾¼
    function saveData() {
        localStorage.setItem('madori_planner_data', JSON.stringify(data));
        alert('ç·¨é›†çŠ¶æ…‹ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
    }
    function loadData() {
        const saved = localStorage.getItem('madori_planner_data');
        if (saved) {
            data = JSON.parse(saved);
            deselect();
            alert('ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
        } else {
            alert('ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
        }
    }

    init();
</script>
</body>
</html>
