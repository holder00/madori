<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é–“å–ã‚ŠPlanner Pro Custom</title>
    <style>
        :root { --primary: #2c3e50; --accent: #e74c3c; --ui-bg: rgba(255,255,255,0.9); }
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #ddd; touch-action: none; }
        canvas { display: block; background: #fff; }

        .ui-panel { position: fixed; background: var(--ui-bg); backdrop-filter: blur(5px); z-index: 100; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #top-bar { top: 10px; left: 10px; right: 10px; height: 50px; display: flex; align-items: center; justify-content: space-between; padding: 0 10px; }
        
        #toolbar { bottom: 0; left: 0; width: 100%; display: flex; flex-direction: column; padding-bottom: max(10px, env(safe-area-inset-bottom)); }
        .scroll-menu { display: flex; overflow-x: auto; padding: 10px; gap: 8px; }
        
        button.tool-btn { 
            flex: 0 0 auto; padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; background: white; font-size: 11px; display: flex; flex-direction: column; align-items: center; min-width: 60px;
        }
        button.tool-btn.active { background: #e3f2fd; border-color: var(--primary); font-weight: bold; }

        #edit-menu { display: none; position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%); padding: 10px; gap: 15px; background: var(--primary); color: white; }
        #edit-menu button { background: none; border: 1px solid white; color: white; padding: 5px 10px; border-radius: 4px; font-size: 12px; }
        
        .floor-btn { padding: 5px 15px; border: 1px solid #ccc; background: #fff; border-radius: 20px; }
        .floor-btn.active { background: var(--primary); color: white; }
        #zoom-info { position: fixed; top: 70px; right: 20px; font-size: 10px; color: #666; background: rgba(255,255,255,0.7); padding: 2px 5px; border-radius: 4px; }
    </style>
</head>
<body>

<div id="top-bar" class="ui-panel">
    <div>
        <button class="floor-btn active" id="f1-btn" onclick="changeFloor(1)">1F</button>
        <button class="floor-btn" id="f2-btn" onclick="changeFloor(2)">2F</button>
    </div>
    <div id="status" style="font-size:11px;">ãƒ¢ãƒ¼ãƒ‰: å£ã‚’æã</div>
    <button onclick="resetView()" style="font-size:11px;">è¡¨ç¤ºãƒªã‚»ãƒƒãƒˆ</button>
</div>

<div id="zoom-info">ã‚ºãƒ¼ãƒ : 100% (äºŒæœ¬æŒ‡ã§æ‹¡å¤§ç¸®å°)</div>

<div id="edit-menu" class="ui-panel">
    <span id="select-label" style="font-size:10px; margin-right:10px;"></span>
    <button onclick="rotateObject()">âŸ³ å›è»¢</button>
    <button onclick="deleteObject()" style="color:#ffadad;">ğŸ—‘ å‰Šé™¤</button>
    <button onclick="deselect()">Ã— é–‰ã˜ã‚‹</button>
</div>

<canvas id="canvas"></canvas>

<div id="toolbar" class="ui-panel">
    <div class="scroll-menu">
        <button id="btn-wall" class="tool-btn active" onclick="setMode('wall')">ğŸ§±<span>å£</span></button>
        <button id="btn-area-kitchen" class="tool-btn" onclick="setMode('area', 'kitchen')">ğŸ³<span>ã‚­ãƒƒãƒãƒ³ã‚¹ãƒšãƒ¼ã‚¹</span></button>
        <button id="btn-area-void" class="tool-btn" onclick="setMode('area', 'void')">ğŸ•³<span>å¹ãæŠœã‘ç¯„å›²</span></button>
        <button id="btn-select" class="tool-btn" onclick="setMode('select')">ğŸ‘†<span>é¸æŠ/æ¶ˆå»</span></button>
        <button class="tool-btn" onclick="setAddItem('door')">ğŸšª<span>ãƒ‰ã‚¢</span></button>
        <button class="tool-btn" onclick="setAddItem('stair')">ğŸªœ<span>éšæ®µ</span></button>
        <button class="tool-btn" onclick="setAddItem('bath100')">ğŸ›<span>é¢¨å‘‚1åª</span></button>
        <button class="tool-btn" onclick="setAddItem('toilet')">ğŸš½<span>ãƒˆã‚¤ãƒ¬</span></button>
    </div>
</div>

<script>
    const GRID_UNIT = 20; // 0.25é–“ãƒ™ãƒ¼ã‚¹
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // çŠ¶æ…‹ç®¡ç†
    let data = { 1: { objects: [] }, 2: { objects: [] } };
    let currentFloor = 1;
    let mode = 'wall'; 
    let activeAreaType = null;
    let selectedObj = null;

    // ã‚«ãƒ¡ãƒ©ï¼ˆã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³ï¼‰çŠ¶æ…‹
    let camera = { x: 0, y: 0, zoom: 1.0 };
    let isDragging = false, isPinching = false;
    let lastTouch = { x: 0, y: 0 }, startDist = 0;
    
    // æç”»ä¸­ã®ä¸€æ™‚ãƒ‡ãƒ¼ã‚¿
    let tempPoints = []; // ä»»æ„å½¢çŠ¶ç”¨
    let startPos = {x:0, y:0}, currentPos = {x:0, y:0};

    function init() {
        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('touchstart', onTouchStart, {passive: false});
        canvas.addEventListener('touchmove', onTouchMove, {passive: false});
        canvas.addEventListener('touchend', onTouchEnd);
        draw();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        draw();
    }

    // ç”»é¢åº§æ¨™ã‹ã‚‰å›³é¢åº§æ¨™ã¸å¤‰æ›
    function screenToWorld(x, y) {
        return {
            x: (x - camera.x) / camera.zoom,
            y: (y - camera.y) / camera.zoom
        };
    }

    function snap(val) { return Math.round(val / GRID_UNIT) * GRID_UNIT; }

    function onTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 2) {
            isPinching = true;
            startDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
        } else {
            isDragging = true;
            const touch = e.touches[0];
            lastTouch = { x: touch.pageX, y: touch.pageY };
            
            const worldPos = screenToWorld(touch.pageX, touch.pageY);
            startPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
            currentPos = { ...startPos };

            if (mode === 'select') {
                handleSelection(startPos.x, startPos.y);
            } else if (mode === 'area') {
                tempPoints.push({ x: startPos.x, y: startPos.y });
                // å§‹ç‚¹ã«æˆ»ã£ãŸã‚‰ç¢ºå®š
                if (tempPoints.length > 2 && startPos.x === tempPoints[0].x && startPos.y === tempPoints[0].y) {
                    completeArea();
                }
            } else if (mode === 'add') {
                placeItem(startPos.x, startPos.y);
            }
        }
        draw();
    }

    function onTouchMove(e) {
        e.preventDefault();
        if (isPinching && e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            const delta = dist / startDist;
            camera.zoom = Math.min(Math.max(camera.zoom * delta, 0.5), 3.0);
            startDist = dist;
            document.getElementById('zoom-info').innerText = `ã‚ºãƒ¼ãƒ : ${Math.round(camera.zoom*100)}%`;
        } else if (isDragging) {
            const touch = e.touches[0];
            if (mode === 'select' && !selectedObj) {
                // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ´ã‚“ã§ã„ãªã„æ™‚ã¯ãƒ‘ãƒ³(ç§»å‹•)
                camera.x += (touch.pageX - lastTouch.x);
                camera.y += (touch.pageY - lastTouch.y);
            } else {
                const worldPos = screenToWorld(touch.pageX, touch.pageY);
                currentPos = { x: snap(worldPos.x), y: snap(worldPos.y) };
            }
            lastTouch = { x: touch.pageX, y: touch.pageY };
        }
        draw();
    }

    function onTouchEnd() {
        if (mode === 'wall' && isDragging) {
            if (startPos.x !== currentPos.x || startPos.y !== currentPos.y) {
                data[currentFloor].objects.push({
                    id: Date.now(), type: 'wall', x1: startPos.x, y1: startPos.y, x2: currentPos.x, y2: currentPos.y
                });
            }
        }
        isDragging = false;
        isPinching = false;
        draw();
    }

    function handleSelection(x, y) {
        const objs = data[currentFloor].objects;
        let found = null;
        for (let i = objs.length - 1; i >= 0; i--) {
            const o = objs[i];
            if (o.type === 'wall') {
                if (distToSegment({x, y}, {x:o.x1, y:o.y1}, {x:o.x2, y:o.y2}) < 15) found = o;
            } else if (o.type === 'area') {
                if (isPointInPoly({x,y}, o.points)) found = o;
            } else {
                if (x >= o.x && x <= o.x + (o.w||4)*GRID_UNIT && y >= o.y && y <= o.y + (o.h||4)*GRID_UNIT) found = o;
            }
            if (found) break;
        }
        selectedObj = found;
        if (found) {
            document.getElementById('edit-menu').style.display = 'flex';
            document.getElementById('select-label').innerText = found.type;
        } else {
            deselect();
        }
    }

    function completeArea() {
        if (tempPoints.length < 3) return;
        data[currentFloor].objects.push({
            id: Date.now(), type: 'area', areaType: activeAreaType,
            points: [...tempPoints],
            color: activeAreaType === 'kitchen' ? 'rgba(243, 156, 18, 0.4)' : 'rgba(0,0,0,0.1)',
            isVoid: activeAreaType === 'void'
        });
        tempPoints = [];
        setMode('select');
    }

    function setMode(m, sub) {
        mode = m; activeAreaType = sub;
        tempPoints = [];
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        if (sub) document.getElementById('btn-area-'+sub).classList.add('active');
        else if (document.getElementById('btn-'+m)) document.getElementById('btn-'+m).classList.add('active');
        document.getElementById('status').innerText = `ãƒ¢ãƒ¼ãƒ‰: ${m} ${sub||''}`;
        deselect();
    }

    function setAddItem(type) {
        mode = 'add'; activeItemType = type;
        setMode('add');
        document.getElementById('status').innerText = `é…ç½®ãƒ¢ãƒ¼ãƒ‰: ${type}`;
    }

    function placeItem(x, y) {
        const presets = {
            'door': { w: 4, h: 4, type: 'door' },
            'stair': { w: 4, h: 8, type: 'rect', label: 'éšæ®µ', color: '#bdc3c7' },
            'bath100': { w: 8, h: 8, type: 'rect', label: 'é¢¨å‘‚', color: '#3498db' },
            'toilet': { w: 4, h: 4, type: 'rect', label: 'ãƒˆã‚¤ãƒ¬', color: '#1abc9c' }
        };
        const p = presets[activeItemType];
        data[currentFloor].objects.push({ ...p, id: Date.now(), x, y, rotation: 0 });
        setMode('select');
    }

    function draw() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.translate(camera.x, camera.y);
        ctx.scale(camera.zoom, camera.zoom);

        // ã‚°ãƒªãƒƒãƒ‰
        ctx.strokeStyle = '#eee';
        const viewW = canvas.width / camera.zoom + 200;
        const viewH = canvas.height / camera.zoom + 200;
        for(let i=-2000; i<3000; i+=GRID_UNIT){
            ctx.beginPath(); ctx.lineWidth=i%(GRID_UNIT*4)===0?1:0.3;
            ctx.moveTo(i,-2000); ctx.lineTo(i,3000); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-2000,i); ctx.lineTo(3000,i); ctx.stroke();
        }

        // éšå±¤è¡¨ç¤º
        if (currentFloor === 2) {
            ctx.globalAlpha = 0.1;
            data[1].objects.forEach(renderObj);
            ctx.globalAlpha = 1.0;
        }
        data[currentFloor].objects.forEach(renderObj);

        // ä½œæ¥­ä¸­è¡¨ç¤º
        if (mode === 'wall' && isDragging) {
            ctx.strokeStyle = '#3498db'; ctx.lineWidth = 5;
            ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(currentPos.x, currentPos.y); ctx.stroke();
        }
        if (tempPoints.length > 0) {
            ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 2;
            ctx.beginPath();
            tempPoints.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.lineTo(currentPos.x, currentPos.y);
            ctx.stroke();
            // å§‹ç‚¹ã‚’å¼·èª¿ï¼ˆé–‰ã˜ã‚„ã™ãã™ã‚‹ãŸã‚ï¼‰
            ctx.fillStyle = 'red';
            ctx.beginPath(); ctx.arc(tempPoints[0].x, tempPoints[0].y, 8/camera.zoom, 0, Math.PI*2); ctx.fill();
        }
    }

    function renderObj(o) {
        ctx.save();
        const isSelected = selectedObj && selectedObj.id === o.id;
        if (o.type === 'wall') {
            ctx.strokeStyle = isSelected ? 'red' : '#333';
            ctx.lineWidth = 8; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(o.x1, o.y1); ctx.lineTo(o.x2, o.y2); ctx.stroke();
        } else if (o.type === 'area') {
            ctx.fillStyle = o.color;
            ctx.beginPath();
            o.points.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.closePath(); ctx.fill();
            ctx.strokeStyle = isSelected ? 'red' : '#7f8c8d';
            ctx.lineWidth = 2; ctx.stroke();
        } else if (o.type === 'door') {
            ctx.translate(o.x, o.y); ctx.rotate(o.rotation * Math.PI / 180);
            ctx.strokeStyle = isSelected ? 'red' : '#e74c3c'; ctx.lineWidth = 3;
            const size = 4 * GRID_UNIT;
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, size); ctx.stroke();
            ctx.setLineDash([5, 5]);
            ctx.beginPath(); ctx.arc(0, 0, size, Math.PI/2, 0, true); ctx.stroke();
        } else {
            ctx.translate(o.x, o.y); ctx.rotate(o.rotation * Math.PI / 180);
            ctx.fillStyle = o.color; ctx.strokeStyle = isSelected ? 'red' : '#333';
            ctx.fillRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            ctx.strokeRect(0, 0, o.w * GRID_UNIT, o.h * GRID_UNIT);
            ctx.fillStyle = '#000'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
            ctx.fillText(o.label, (o.w * GRID_UNIT)/2, (o.h * GRID_UNIT)/2);
        }
        ctx.restore();
    }

    // æ•°å­¦ãƒ˜ãƒ«ãƒ‘ãƒ¼
    function distToSegment(p, v, w) {
        const l2 = Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
        if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
    }
    function isPointInPoly(p, poly) {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            if (((poly[i].y > p.y) !== (poly[j].y > p.y)) && (p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) inside = !inside;
        }
        return inside;
    }

    // UIæ“ä½œ
    function rotateObject() { if(selectedObj && selectedObj.type !== 'wall') { selectedObj.rotation = (selectedObj.rotation + 90) % 360; draw(); } }
    function deleteObject() { if(selectedObj) { data[currentFloor].objects = data[currentFloor].objects.filter(o => o.id !== selectedObj.id); deselect(); } }
    function deselect() { selectedObj = null; document.getElementById('edit-menu').style.display = 'none'; draw(); }
    function changeFloor(f) { currentFloor = f; document.getElementById('f1-btn').classList.toggle('active', f===1); document.getElementById('f2-btn').classList.toggle('active', f===2); draw(); }
    function resetView() { camera = { x: 0, y: 0, zoom: 1.0 }; draw(); }

    init();
</script>
</body>
</html>
